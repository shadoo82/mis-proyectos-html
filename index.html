<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Libro de √ìrdenes Mejorado - Futuros Binance</title>
  <style>
    :root {
      --bg-color: #121212;
      --panel-color: #1e1e1e;
      --border-color: #333;
      --text-color: #e0e0e0;
      --text-secondary: #888;
      --ask-color: #ff5555;
      --bid-color: #00ff88;
      --highlight-ask: rgba(255, 85, 85, 0.3);
      --highlight-bid: rgba(0, 255, 136, 0.3);
      --color-purple: #9c27b0;
      --blue-color: #2196f3;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 15px;
      margin: 0;
      padding: 10px;
      position: relative;
      min-height: 100vh;
    }

    /* ========== BARRA SUPERIOR ESTILO IMAGEN ========== */
    .header-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        width: 100%;
        padding: 10px 15px;
        background: linear-gradient(90deg, #1a1a1a 0%, #222 100%);
        border-radius: 0;
        box-sizing: border-box;
        margin: 0 auto 10px auto;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        border: 1px solid #333;
        border-bottom: 2px solid #444;
    }

    .header-left {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-grow: 1;
    }

    .search-container {
        display: flex;
        align-items: center;
        gap: 5px;
        background: rgba(0, 0, 0, 0.3);
        padding: 4px 8px;
        border-radius: 3px;
        border: 1px solid #444;
    }

    .search-container label {
        margin-right: 3px;
        font-size: 10px;
        color: var(--text-secondary);
        white-space: nowrap;
    }

    .search-container input {
        background-color: rgba(0, 0, 0, 0.5);
        color: var(--text-color);
        border: 1px solid #444;
        padding: 4px 8px;
        font-size: 10px;
        border-radius: 3px;
        width: 100px;
        transition: all 0.2s ease;
        min-height: 26px;
        font-family: 'Consolas', monospace;
    }

    .search-container input:focus {
        outline: none;
        border-color: var(--bid-color);
        box-shadow: 0 0 0 2px rgba(0, 255, 0, 0.1);
    }

    .symbol-title {
        margin-left: 10px;
        white-space: nowrap;
        font-size: 16px;
        font-weight: 600;
        color: var(--bid-color);
        background: rgba(0, 255, 136, 0.1);
        padding: 4px 10px;
        border-radius: 3px;
        border: 1px solid rgba(0, 255, 136, 0.3);
        text-shadow: 0 0 5px rgba(0, 255, 136, 0.3);
    }

    .header-info-line {
        margin: 0;
        line-height: 1.2;
        white-space: nowrap;
        color: var(--text-secondary);
    }

    .interval-selector {
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(0, 0, 0, 0.3);
        padding: 4px 8px;
        border-radius: 3px;
        border: 1px solid #444;
    }

    .interval-selector label {
        color: var(--text-secondary);
        font-size: 10px;
        white-space: nowrap;
    }

    .interval-selector select {
        background-color: rgba(0, 0, 0, 0.5);
        color: var(--text-color);
        border: 1px solid #444;
        padding: 4px 8px;
        font-size: 10px;
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s ease;
        width: 70px;
        min-height: 26px;
        font-family: 'Consolas', monospace;
    }

    .interval-selector button {
        background-color: rgba(0, 0, 0, 0.5);
        color: var(--text-color);
        border: 1px solid #444;
        padding: 4px 8px;
        font-size: 10px;
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s ease;
        min-height: 26px;
        white-space: nowrap;
        font-family: 'Consolas', monospace;
    }

    .interval-selector button:hover {
        background-color: rgba(0, 255, 136, 0.2);
        border-color: var(--bid-color);
    }

    .interval-selector select:hover {
        border-color: var(--bid-color);
    }

    .error-message {
      color: var(--ask-color);
      text-align: center;
      margin: 8px 0;
      font-size: 10px;
    }

    .loading-message {
      color: var(--bid-color);
      text-align: center;
      margin: 8px 0;
      font-size: 10px;
    }

    /* ========== GR√ÅFICO ESTILO IMAGEN ========== */
    .chart-container {
      width: 100%;
      height: 400px;
      margin: 10px 0;
      border: 1px solid #333;
      background-color: #0f0f0f;
      border-radius: 0;
      position: relative;
    }

    .container {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .panel {
      flex: 1;
      border: 1px solid #333;
      background-color: #151515;
      padding: 5px 8px 8px 8px;
      min-width: 300px;
      border-radius: 0;
      position: relative;
    }

    .title-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      width: 100%;
      text-align: center;
      margin-top: -5px;
      margin-bottom: 8px;
      padding-bottom: 5px;
      border-bottom: 1px solid #333;
    }

    h2 {
      margin: 0;
      color: var(--bid-color);
      font-size: 14px;
      font-weight: 600;
    }

    .asks-title {
      color: var(--ask-color);
    }

    .processed-count {
      font-size: 14px;
      font-weight: bold;
    }

    .asks-processed {
      color: var(--ask-color);
    }

    .bids-processed {
      color: var(--bid-color);
    }

    .indicator-circle {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .indicator-circle-start {
      margin-right: 5px;
    }

    .indicator-circle-end {
      margin-left: 5px;
    }

    .circle-red {
      background-color: var(--ask-color) !important;
    }

    .circle-green {
      background-color: var(--bid-color) !important;
    }

    /* ========== TABLAS ESTILO IMAGEN ========== */
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: #0f0f0f;
      border: 1px solid #333;
      margin-bottom: 8px;
      font-size: 10px;
      border-radius: 0;
      overflow: hidden;
    }

    th, td {
      padding: 4px 5px;
      border: 1px solid #2a2a2a;
      position: relative;
      cursor: pointer;
      line-height: 1.1;
      text-align: center;
      font-family: 'Consolas', monospace;
    }

    th {
      background-color: #1a1a1a;
      color: var(--bid-color);
      font-weight: 500;
      position: sticky;
      top: 0;
      font-size: 10px;
      border-bottom: 2px solid #333;
    }

    td {
      color: var(--text-secondary);
      user-select: none;
      font-size: 10px;
    }

    td span {
      display: inline-block;
      width: 100%;
      text-align: center;
      user-select: text;
    }

    td::selection, td span::selection {
      background: rgba(0, 255, 0, 0.3);
    }

    .ask-row { 
      color: #ff8888; 
      background: rgba(255, 85, 85, 0.02);
    }
    .bid-row { 
      color: #88ffaa; 
      background: rgba(0, 255, 136, 0.02);
    }

    tr:hover { background-color: rgba(255, 255, 255, 0.05); }

    .bold-row td {
      font-weight: bold;
    }

    .color-transparent {
      background-color: transparent;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }

    .color-purple {
      background-color: rgba(156, 39, 176, 0.2);
      color: #ddaaff;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }

    .color-purple td {
      color: #ddaaff;
    }

    .highlight-red {
      background-color: var(--highlight-ask) !important;
      transition: background-color 1s ease-out;
    }

    .highlight-red td {
      color: #ffffff !important;
      font-weight: bold;
    }

    tr.highlight-green {
      background-color: var(--highlight-bid) !important;
      transition: background-color 1s ease-out;
    }

    tr.highlight-green td {
      color: #000000 !important;
      font-weight: bold;
    }

    .legend {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-top: 6px;
    }

    .legend-row {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 3px;
      border-radius: 0;
      font-size: 8px;
      background-color: #1a1a1a;
      color: var(--text-secondary);
      margin-bottom: 2px;
      line-height: 1;
      border: 1px solid #333;
    }

    .legend .bid-updated-legend {
      background-color: rgba(0, 255, 136, 0.2) !important;
      color: #000000 !important;
    }

    .copied {
      background-color: rgba(0, 255, 0, 0.3);
      transition: background-color 0.5s ease;
    }

    .price-cell:hover {
      background-color: rgba(0, 255, 0, 0.1);
      transition: none;
    }

    .highlight-total {
      background-color: rgba(0, 77, 0, 0.3);
      padding: 1px 3px;
      border-radius: 3px;
      font-size: 10px;
    }

    .selected-row {
      background-color: rgba(0, 255, 0, 0.3) !important;
    }

    .selected-column {
      width: 25px;
      text-align: center;
      position: relative;
    }

    .selected-column:hover {
      background-color: rgba(0, 255, 0, 0.1);
    }

    .selection-checkbox {
      cursor: pointer;
      width: 12px;
      height: 12px;
    }

    .selection-checkbox:checked {
      accent-color: var(--ask-color);
    }

    #bids-body .selection-checkbox:checked {
      accent-color: var(--bid-color);
    }

    .selection-checkbox:active {
      outline: 2px solid var(--bid-color);
    }

    .spinner {
      border: 2px solid rgba(0, 255, 0, 0.3);
      border-radius: 50%;
      border-top: 2px solid var(--bid-color);
      width: 12px;
      height: 12px;
      animation: spin 1s linear infinite;
      display: inline-block;
      vertical-align: middle;
      margin-left: 5px;
    }

    .panel-alert {
      position: absolute;
      top: 5px;
      font-size: 10px;
      font-weight: bold;
      padding: 2px 5px;
      border-radius: 3px;
      animation: flash 1s ease-in-out;
      z-index: 100;
    }

    .ask-alert {
      right: 10px;
      color: var(--ask-color);
      background-color: rgba(255, 85, 85, 0.2);
    }

    .bid-alert {
      left: 10px;
      color: var(--bid-color);
      background-color: rgba(85, 255, 85, 0.2);
    }

    /* ========== ESTAD√çSTICAS ESTILO IMAGEN ========== */
    .market-stats-container {
      background-color: #151515;
      border-radius: 0;
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #333;
      box-shadow: none;
    }

    .stats-panel h3 {
      margin: 0 0 8px 0;
      color: #00aaff;
      font-size: 12px;
      text-align: center;
      padding-bottom: 6px;
      border-bottom: 1px solid #333;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }

    .stats-column {
      padding: 6px;
      border-radius: 0;
      border: 1px solid #2a2a2a;
    }

    .bid-stats {
      background-color: rgba(0, 255, 136, 0.05);
      border-left: 3px solid var(--bid-color);
    }

    .ask-stats {
      background-color: rgba(255, 85, 85, 0.05);
      border-left: 3px solid var(--ask-color);
    }

    .spread-stats {
      background-color: rgba(255, 255, 0, 0.05);
      border-left: 3px solid #ffaa00;
    }

    .imbalance-container {
      margin-top: 10px;
      padding: 8px;
      background-color: rgba(0,0,0,0.3);
      border-radius: 0;
      border: 1px solid #333;
      text-align: center;
    }

    .imbalance-label {
      font-size: 10px;
      color: var(--text-secondary);
      margin-right: 8px;
    }

    .imbalance-value {
      font-weight: bold;
      font-size: 11px;
    }

    .imbalance-bar {
      height: 10px;
      background: linear-gradient(to right, var(--ask-color), var(--bid-color));
      border-radius: 0;
      margin-top: 6px;
      position: relative;
    }

    .imbalance-indicator {
      position: absolute;
      height: 14px;
      width: 3px;
      background-color: white;
      top: -2px;
      transform: translateX(-50%);
      border-radius: 0;
    }

    .alert-container {
      position: fixed;
      bottom: 15px;
      right: 15px;
      max-width: 250px;
      z-index: 1000;
    }

    .market-alert {
      padding: 6px 10px;
      margin: 4px 0;
      border-radius: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      animation: fadeIn 0.3s ease;
      font-size: 10px;
      background-color: #151515;
      border: 1px solid #333;
      border-left: 3px solid;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }

    .alert-time {
      color: var(--text-secondary);
      font-size: 9px;
      margin-right: 8px;
    }

    .alert-message {
      flex-grow: 1;
    }

    .alert-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 12px;
      margin-left: 8px;
    }

    .spread-alert {
      border-left: 3px solid orange;
    }

    .imbalance-alert {
      border-left: 3px solid mediumpurple;
    }

    .volume-alert {
      border-left: 3px solid deepskyblue;
    }

    .liquidity-controls-stats {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      padding: 8px;
      background-color: rgba(0,0,0,0.3);
      border-radius: 0;
      border: 1px solid #333;
    }

    .liquidity-thresholds-stats {
      display: flex;
      gap: 5px;
      align-items: center;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 1100px) {
        .header-controls {
            flex-direction: column;
            gap: 8px;
            padding: 8px 10px;
        }
        
        .header-left, .header-center, .interval-selector {
            width: 100%;
            justify-content: center;
            text-align: center;
        }
        
        .search-container {
            width: 100%;
            justify-content: center;
        }
        
        .symbol-title {
            margin-left: 0;
            margin-top: 3px;
        }
        
        .header-center {
            margin: 3px 0;
        }
    }

    @keyframes flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .tradingview-lightweight-charts-marker-tooltip {
      font-family: 'Courier New', monospace !important;
      font-size: 9px !important;
      background: rgba(40, 40, 40, 0.95) !important;
      border: 1px solid #333 !important;
      border-radius: 0 !important;
      padding: 4px 6px !important;
      line-height: 1.4 !important;
      white-space: nowrap !important;
      color: #FFFFFF !important;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3) !important;
    }

    .alert-icon {
        font-size: 14px;
        margin-right: 10px;
        font-weight: bold;
    }

    .fade-out {
        animation: fadeOut 0.5s ease forwards;
    }

    @keyframes fadeOut {
        to { opacity: 0; transform: translateY(10px); }
    }

    .heatmap-off {
        background-color: #dc3545 !important;
        color: white !important;
        font-weight: bold;
        border: 1px solid #ff5555 !important;
    }

    @keyframes heatmapGlow {
        from { box-shadow: 0 0 3px #28a745, 0 0 6px #28a745; }
        to { box-shadow: 0 0 8px #28a745, 0 0 14px #28a745; }
    }

    .fullscreen-btn {
        position: absolute;
        top: 5px;
        right: 5px;
        width: 28px;
        height: 28px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #444;
        border-radius: 3px;
        cursor: pointer;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
    }

    .fullscreen-btn:hover {
        background: rgba(0, 0, 0, 0.9);
        border-color: var(--bid-color);
        transform: scale(1.05);
    }

    .fullscreen-btn svg {
        width: 14px;
        height: 14px;
        fill: var(--bid-color);
    }

    .chart-container.fullscreen-mode {
    position: fixed !important;
    top: 50px !important; /* DEBE SER 50px, NO 0 */
    left: 0 !important;
    width: 100vw !important;
    height: calc(100vh - 50px) !important; /* Altura menos el header */
    background: #000 !important;
    z-index: 9999 !important;
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    border-radius: 0 !important;
}

    body.fullscreen-active .hide-when-fullscreen {
        display: none !important;
        opacity: 0 !important;
        visibility: hidden !important;
        height: 0 !important;
        overflow: hidden !important;
    }

    /* ========== CORRECCIONES PARA MODO PANTALLA COMPLETA ========== */
    body.fullscreen-active .header-controls {
        display: flex !important;
        position: fixed !important;
        top: 0 !important; /* Cambiado de 10px a 0 */
        left: 0 !important; /* Cambiado de 50% a 0 */
        transform: none !important; /* Eliminado transform */
        width: 100% !important; /* Cambiado de 98% a 100% */
        height: auto !important;
        z-index: 10000 !important;
        margin: 0 !important;
        padding: 8px 15px !important;
        background-color: rgba(26, 26, 26, 0.95) !important; /* Fondo semi-transparente */
        border-radius: 0 !important;
        border-bottom: 2px solid #333 !important; /* Solo borde inferior */
        border-top: none !important;
        border-left: none !important;
        border-right: none !important;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.7) !important;
        backdrop-filter: blur(5px); /* Efecto de desenfoque */
    }

    /* Asegurar que el contenido est√© alineado y centrado en fullscreen */
    body.fullscreen-active .header-controls .header-left,
    body.fullscreen-active .header-controls .header-center,
    body.fullscreen-active .header-controls .interval-selector {
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        flex-wrap: nowrap !important;
        height: 100% !important;
        padding: 4px 0 !important;
    }

    /* Ajustar el input de b√∫squeda */
    body.fullscreen-active .header-controls .search-container {
        min-width: 180px !important;
        margin: 0 5px !important;
    }

    body.fullscreen-active .header-controls input[type="text"] {
        width: 120px !important;
        min-height: 26px !important;
    }

    /* Ajustar el s√≠mbolo del t√≠tulo */
    body.fullscreen-active .header-controls .symbol-title {
        font-size: 16px !important;
        margin: 0 10px !important;
        padding: 4px 12px !important;
        white-space: nowrap !important;
    }

    /* Ajustar el centro del header */
    body.fullscreen-active .header-controls .header-center {
        min-width: 250px !important;
        max-width: 350px !important;
        padding: 4px 10px !important;
        margin: 0 10px !important;
    }

    body.fullscreen-active .header-controls .header-info-line {
        font-size: 11px !important;
        line-height: 1.3 !important;
    }

    /* Ajustar el selector de intervalo */
    body.fullscreen-active .header-controls .interval-selector {
        min-width: 150px !important;
        margin: 0 5px !important;
    }

    /* Ajustar el bot√≥n de fullscreen para que est√© sobre el gr√°fico */
    .chart-container.fullscreen-mode .fullscreen-btn {
        position: fixed !important;
        top: 15px !important; /* Cambiado para que est√© justo debajo del header */
        right: 15px !important;
        z-index: 10002 !important; /* Mayor z-index que el header */
        background-color: rgba(0, 0, 0, 0.8) !important;
        border-color: var(--bid-color) !important;
        box-shadow: 0 0 10px rgba(0, 255, 136, 0.3) !important;
    }

    /* Asegurar que el gr√°fico est√© debajo del header */
    .chart-container.fullscreen-mode {
        position: fixed !important;
        top: 50px !important; /* Dejar espacio para el header */
        left: 0 !important;
        width: 100vw !important;
        height: calc(100vh - 50px) !important; /* Altura menos el header */
        background: #000 !important;
        z-index: 9999 !important;
        margin: 0 !important;
        padding: 0 !important;
        border: none !important;
        border-radius: 0 !important;
    }

    body.fullscreen-active {
        padding-top: 0 !important;
        overflow: hidden !important;
    }

    /* Asegurar que el canvas del heatmap tambi√©n se ajuste */
    .chart-container.fullscreen-mode canvas#heatmapCanvas {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
    }

    /* Media query para pantallas m√°s peque√±as en fullscreen */
    @media (max-width: 1100px) {
        body.fullscreen-active .header-controls {
            flex-direction: row !important;
            flex-wrap: wrap !important;
            height: auto !important;
            padding: 6px 10px !important;
        }
        
        body.fullscreen-active .header-controls .header-left,
        body.fullscreen-active .header-controls .header-center,
        body.fullscreen-active .header-controls .interval-selector {
            width: auto !important;
            min-width: auto !important;
            margin: 3px 5px !important;
            flex-shrink: 0 !important;
        }
        
        .chart-container.fullscreen-mode {
            top: 70px !important; /* M√°s espacio para header de 2 l√≠neas */
            height: calc(100vh - 70px) !important;
        }
    }

    /* Para pantallas muy peque√±as */
    @media (max-width: 768px) {
        body.fullscreen-active .header-controls {
            flex-direction: column !important;
            height: auto !important;
            padding: 6px 8px !important;
        }
        
        body.fullscreen-active .header-controls .header-left,
        body.fullscreen-active .header-controls .header-center,
        body.fullscreen-active .header-controls .interval-selector {
            width: 100% !important;
            justify-content: center !important;
            margin: 3px 0 !important;
        }
        
        .chart-container.fullscreen-mode {
            top: 100px !important;
            height: calc(100vh - 100px) !important;
        }
    }

    .chart-container {
        height: 400px;
        margin-top: 8px;
    }

    /* ========== BOTONES ESTILO IMAGEN ========== */
    .liquidity-btn {
        background-color: #1a1a1a;
        color: var(--text-color);
        border: 1px solid #444;
        padding: 4px 8px;
        font-size: 10px;
        border-radius: 3px;
        cursor: pointer;
        font-family: 'Consolas', monospace;
        transition: all 0.2s ease;
    }

    .liquidity-btn:hover {
        background-color: rgba(0, 255, 136, 0.1);
        border-color: var(--bid-color);
    }

    /* ========== INPUTS ESTILO IMAGEN ========== */
    .liquidity-thresholds input {
        background-color: rgba(0, 0, 0, 0.5);
        color: var(--text-color);
        border: 1px solid #444;
        padding: 4px 6px;
        font-size: 10px;
        border-radius: 3px;
        font-family: 'Consolas', monospace;
        width: 80px;
    }

    .liquidity-thresholds input:focus {
        outline: none;
        border-color: var(--bid-color);
        box-shadow: 0 0 0 2px rgba(0, 255, 0, 0.1);
    }

    /* ========== SCROLLBAR ESTILO IMAGEN ========== */
    ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
    }

    ::-webkit-scrollbar-track {
        background: #1a1a1a;
    }

    ::-webkit-scrollbar-thumb {
        background: #444;
        border-radius: 0;
    }

    ::-webkit-scrollbar-thumb:hover {
        background: #555;
    }

    /* ========== DISE√ëO MEJORADO PARA EL PRECIO BTCUSDT ========== */
    .symbol-display {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        margin-left: 15px;
    }

    .symbol-main {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .symbol-title {
        white-space: nowrap;
        font-size: 16px;
        font-weight: 700;
        color: var(--text-color);
        background: linear-gradient(135deg, #1a1a1a 0%, #222 100%);
        padding: 6px 14px;
        border-radius: 6px;
        border: 1px solid #444;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        font-family: 'Segoe UI', system-ui, sans-serif;
    }

    .price-container {
        display: flex;
        flex-direction: column;
        background: rgba(0, 0, 0, 0.4);
        border-radius: 6px;
        padding: 6px 12px;
        border: 1px solid #444;
        min-width: 200px;
    }

    .price-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
    }

    .symbol-name {
        font-size: 14px;
        font-weight: 600;
        color: var(--bid-color);
        text-shadow: 0 0 8px rgba(0, 255, 136, 0.3);
    }

    .price-value {
        font-size: 16px;
        font-weight: 700;
        color: #ffffff;
        font-family: 'Segoe UI', system-ui, sans-serif;
        letter-spacing: 0.5px;
    }

    .price-change {
        display: flex;
        align-items: center;
        font-size: 12px;
        font-weight: 600;
        padding: 3px 8px;
        border-radius: 4px;
    }

    .price-change.positive {
        background: rgba(76, 175, 80, 0.2);
        color: #4caf50;
        border: 1px solid rgba(76, 175, 80, 0.3);
    }

    .price-change.negative {
        background: rgba(244, 67, 54, 0.2);
        color: #f44336;
        border: 1px solid rgba(244, 67, 54, 0.3);
    }

    .price-change::before {
        content: "‚ñ≤";
        margin-right: 3px;
        font-size: 10px;
    }

    .price-change.negative::before {
        content: "‚ñº";
    }

    /* ========== HEADER CENTER MEJORADO ========== */
    .header-center {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        flex-grow: 1;
        font-family: 'Courier New', monospace;
        font-size: 13px;
        padding: 6px 12px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 6px;
        border: 1px solid #444;
        min-width: 280px;
        margin: 0 105px;
    }

    .header-info-line {
        margin: 0;
        line-height: 1.3;
        white-space: nowrap;
        color: var(--text-secondary);
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .header-info-line strong {
        color: var(--text-color);
        font-weight: 600;
    }

    .ws-status {
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .ws-status.connected {
        color: #4caf50;
    }

    .ws-status.connecting {
        color: #ff9800;
    }

    .ws-status.disconnected {
        color: #f44336;
    }

    /* ========== MEJORAS PARA MODO FULLSCREEN ========== */
    body.fullscreen-active .price-container {
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid var(--bid-color);
        box-shadow: 0 0 15px rgba(0, 255, 136, 0.2);
    }

    body.fullscreen-active .price-value {
        font-size: 18px;
    }

    body.fullscreen-active .symbol-title {
        font-size: 17px;
        border-color: var(--bid-color);
    }

    /* ========== RESPONSIVE MEJORADO ========== */
    @media (max-width: 1100px) {
        .symbol-display {
            margin-left: 0;
            align-items: center;
            width: 100%;
        }
        
        .price-container {
            width: 100%;
            max-width: 400px;
        }
    }

    @media (max-width: 768px) {
        .symbol-main {
            flex-direction: column;
            gap: 8px;
        }
        
        .price-row {
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }
        
        .price-container {
            min-width: auto;
            width: 100%;
        }

            /* ========== DISE√ëO DE INFORMACI√ìN DEL S√çMBOLO ========== */
    .symbol-info-display {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-left: 10px;
        padding: 6px 12px;
        background: linear-gradient(135deg, #1a1a1a 0%, #222 100%);
        border-radius: 6px;
        border: 1px solid #444;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        min-width: 250px;
    }

    .symbol-info-item {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .symbol-name-display {
        font-size: 14px;
        font-weight: 600;
        color: var(--bid-color);
        text-shadow: 0 0 8px rgba(0, 255, 136, 0.3);
        margin-bottom: 2px;
    }

    .price-display {
        font-size: 16px;
        font-weight: 700;
        color: #ffffff;
        font-family: 'Segoe UI', system-ui, sans-serif;
        letter-spacing: 0.5px;
    }

    .change-display {
        font-size: 12px;
        font-weight: 600;
        padding: 2px 6px;
        border-radius: 4px;
        margin-top: 2px;
    }

    .change-positive {
        background: rgba(76, 175, 80, 0.2);
        color: #4caf50;
        border: 1px solid rgba(76, 175, 80, 0.3);
    }

    .change-negative {
        background: rgba(244, 67, 54, 0.2);
        color: #f44336;
        border: 1px solid rgba(244, 67, 54, 0.3);
    }

    .orders-display {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-left: 10px;
        padding-left: 10px;
        border-left: 1px solid #444;
    }

    .orders-label {
        font-size: 10px;
        color: var(--text-secondary);
        margin-bottom: 2px;
    }

    .orders-count {
        font-size: 14px;
        font-weight: 700;
        color: var(--bid-color);
    }
 

    #symbol-price-display .price.up {
        color: #4eff78;
        animation: priceUp 0.25s ease;
    }

    #symbol-price-display .price.down {
        color: #ff5555;
        animation: priceDown 0.25s ease;
    }

    #symbol-price-display .pct {
        font-size: 18px;
        font-weight: 700;
    }

    /* Animaciones */
    @keyframes priceUp {
        0% { transform: translateY(0); }
        50% { transform: translateY(-2px); }
        100% { transform: translateY(0); }
    }

    @keyframes priceDown {
        0% { transform: translateY(0); }
        50% { transform: translateY(2px); }
        100% { transform: translateY(0); }
    }


  </style>
  <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
    <!-- üî• BARRA SUPERIOR FIJA (TradingView) -->    
  <div class="header-controls">
    <div class="header-left">
      <div class="search-container hide-when-fullscreen">
        <label for="symbol-search">Buscar par USDT:</label>
        <input type="text" id="symbol-search" placeholder="Ejemplo: BTCUSDT" list="symbol-list" autocomplete="off" aria-label="Buscar par de trading">
        <datalist id="symbol-list"></datalist>
      </div>
      
      <!-- üî• SOLO EL PRECIO, NADA M√ÅS -->
      <div id="symbol-price-display" class="large-price-display" style="margin-left: 15px;">
        <span id="hdr-symbol" class="sym">BTCUSDT</span>
        <span id="hdr-price" class="price">$0.00</span>
        <span id="hdr-change" class="pct">‚ñ≤ 0.00%</span>
      </div>
    </div>

    <div class="header-center">
      <p class="header-info-line" id="compact-timestamp"></p>
      <p class="header-info-line">√ìrdenes procesadas: <strong id="total-prices">0</strong></p>
      <p class="header-info-line">
        <span class="ws-status" id="ws-status">WebSocket: Conectando... <span class="spinner"></span></span>
      </p>
    </div>

    <div class="interval-selector">
      <label for="interval-select">Intervalo:</label>
      <select id="interval-select" aria-label="Seleccionar intervalo de velas">
        <option value="1m">1m</option>
        <option value="3m">3m</option>        
        <option value="5m">5m</option>
        <option value="15m">15m</option>
        <option value="30m">30m</option>
        <option value="1h" selected>1h</option>
        <option value="4h">4h</option>
        <option value="1d">1d</option>
      </select>
      <button onclick="autoScaleChart()" aria-label="Autoajustar gr√°fico">Auto Scale</button>
    </div>
  </div>

  <!-- üî• CONTENEDOR DEL GR√ÅFICO (DEBE IR DEBAJO DE LA BARRA) -->
  <div class="chart-container" id="chart-container">

      <button id="tv-fullscreen-btn" class="fullscreen-btn">
          <svg viewBox="0 0 24 24">
              <path d="M7 14H5v5h5v-2H7v-3zm0-4h2V7h3V5H7v5zm10 7h-3v2h5v-5h-2v3zm-3-7h2V7h3V5h-5v5z"/>
          </svg>
      </button>

      <canvas id="heatmapCanvas"
          style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;">
      </canvas>

      <div class="loading-message">Cargando gr√°fico... <span class="spinner"></span></div>
  </div>

  <div id="error-message" class="error-message"></div>

  <!-- CONTENEDOR DE ESTAD√çSTICAS -->
  <div class="market-stats-container hide-when-fullscreen">
    <div class="stats-panel">
      <h3>Estad√≠sticas de Mercado</h3>

      <div class="stats-grid">
        <div class="stats-column ask-stats">
          <div class="stats-row">
            <span class="stats-label">Liquidez Asks:</span>
            <span class="stats-value" id="total-ask-liquidity">0</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">√ìrdenes grandes:</span>
            <span class="stats-value" id="large-asks-count">0</span>
          </div>
        </div>

        <div class="stats-column spread-stats">
          <div class="stats-row">
            <span class="stats-label">Spread:</span>
            <span class="stats-value" id="market-spread">0</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">Best Bid/Ask:</span>
            <span class="stats-value" id="best-bid-ask">0 / 0</span>
          </div>
        </div>

        <div class="stats-column bid-stats">
          <div class="stats-row">
            <span class="stats-label">Liquidez Bids:</span>
            <span class="stats-value" id="total-bid-liquidity">0</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">√ìrdenes grandes:</span>
            <span class="stats-value" id="large-bids-count">0</span>
          </div>
        </div>
      </div>

      <div class="imbalance-container">
        <span class="imbalance-label">Desequilibrio:</span>
        <span class="imbalance-value" id="orderbook-imbalance">0%</span>
        <div class="imbalance-bar">
          <div class="imbalance-indicator" id="imbalance-indicator"></div>
        </div>
      </div>

      <div class="liquidity-controls-stats">
        <div class="liquidity-thresholds-stats">
          <label>Umbral:</label>
          <input type="number" id="large-threshold" value="50000000" step="1000000">
          <label>Muy grande:</label>
          <input type="number" id="very-large-threshold" value="100000000" step="1000000">
          <button class="liquidity-btn" onclick="updateThresholds()">Aplicar</button>
        </div>

        <div>
          <button class="liquidity-btn" onclick="toggleSoundAlerts()" id="sound-toggle">üîä Sonido: ON</button>
          <button class="liquidity-btn" onclick="toggleClusters()" id="cluster-toggle">üìä Mostrar Clusters</button>
          <button class="liquidity-btn heatmap-off" onclick="toggleHeatmapPro()">‚ùå Heatmap OFF</button>
          <button class="liquidity-btn" onclick="saveKeyLevels()">Guardar Niveles</button>
        </div>
      </div>

    </div>
  </div>

  <div id="alert-container" class="alert-container hide-when-fullscreen"></div>

  <div class="container hide-when-fullscreen">
    <!-- PANEL ASKS -->
    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="asks-indicator-start"></span>
        <h2 class="asks-title">Top Asks (Futuros)</h2>
        <span class="processed-count asks-processed" id="asks-processed">0</span>
        <span class="indicator-circle indicator-circle-end" id="asks-indicator-end"></span>
      </div>

      <table aria-label="√ìrdenes de venta">
        <thead>
          <tr>
            <th>#</th>
            <th>Age</th>
            <th>Price</th>
            <th>Qty</th>
            <th>Usdt</th>
            <th>% Mark</th>
            <th>Hits</th>
            <th class="selected-column">Sel</th>
          </tr>
        </thead>
        <tbody id="asks-body"></tbody>
      </table>

      <div class="legend">
        <div class="legend-row" style="background-color: var(--highlight-ask) !important;">Ask actualizado (Venta)</div>
        <div class="legend-row" style="background-color: var(--color-purple) !important;">√ìrdenes institucionales</div>
      </div>
    </div>

    <!-- PANEL BIDS -->
    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="bids-indicator-start"></span>
        <h2>Top Bids (Futuros)</h2>
        <span class="processed-count bids-processed" id="bids-processed">0</span>
        <span class="indicator-circle indicator-circle-end" id="bids-indicator-end"></span>
      </div>

      <table aria-label="√ìrdenes de compra">
        <thead>
          <tr>
            <th>#</th>
            <th>Age</th>
            <th>Price</th>
            <th>Qty</th>
            <th>Usdt</th>
            <th>% Mark</th>
            <th>Hits</th>
            <th class="selected-column">Sel</th>
          </tr>
        </thead>
        <tbody id="bids-body"></tbody>
      </table>

      <div class="legend">
        <div class="legend-row bid-updated-legend">Bid actualizado (Compra)</div>
        <div class="legend-row" style="background-color: var(--color-purple) !important;">√ìrdenes institucionales</div>
      </div>
    </div>
  </div>

  <!-- TODO TU JAVASCRIPT ORIGINAL SE MANTIENE IGUAL -->
  <script>

        // ===============================
    // üîí FIXES PARA ERRORES (NO BORRAR)
    // ===============================

    // Funci√≥n antigua que el c√≥digo a√∫n llama
    function updateSymbolInfoDisplay() {
        // desactivada a prop√≥sito
    }

    // Calcular cambio porcentual real del precio

    function calculateRealTimeChange() {
        return 0; // desactivada
    }

    // Configuraci√≥n inicial
    const params = new URLSearchParams(window.location.search);
    const symbol = params.get("symbol") || "BTCUSDT";
    //document.getElementById("symbol-title").innerText = `${symbol}: 0.0000 USDT`;

    // URLs de WebSocket
    const futuresWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@depth@100ms`;
    const futuresMarkPriceWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@markPrice@1s`;
    const tickerWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@ticker`;

    // Variables de estado
    let markPriceFutures = 0;
    let lastPriceUpdate = 0;
    let futuresAsksData = [];
    let futuresBidsData = [];
    let precioAnterior = 0; // ‚Üê A√ëADE ESTA L√çNEA
    let asksProcessed = 0;
    let bidsProcessed = 0;
    let pendingUpdate = false;
    let updatePaused = false;
    let isInteracting = false;
    const rowColors = new Map();
    const COLOR_DURATION_MS = 5000;
    let selectedPrices = new Map();

    // =====================================================
    // üß† SISTEMA DE BACKTESTING INTELIGENTE
    // =====================================================
    let zoneBacktestData = JSON.parse(localStorage.getItem(`zoneBacktest_${symbol}`)) || {
        zones: {},
        dailyStats: {},
        correlations: {},
        optimalThresholds: {}
    };

    let currentSessionStats = {
        startTime: Date.now(),
        ordersAtStart: 0,
        zonesHit: 0,
        successfulRebounds: 0,
        failedRebounds: 0,
        totalZones: 0
    };

    let isBacktestMonitoring = true;

    // Continuaci√≥n de tus variables existentes...
    let currentInterval = localStorage.getItem('chartInterval') || '1h';
    document.getElementById('interval-select').value = currentInterval;
    let asksPriceMap = new Map();
    let bidsPriceMap = new Map();
    let chart = null;
    let candlestickSeries = null;
    let emaSeries = null;
    let candlesData = [];
    let lastChartUpdate = 0;
    const CHART_UPDATE_INTERVAL = 1000;
    let klineSocket = null;
    let lastCandle = null;
    let lastAlertElement = null;
    let LARGE_ORDER_THRESHOLD = 50000000; // 50 millones USDT
    let VERY_LARGE_ORDER_THRESHOLD = 100000000; // 100 millones USDT
    let liquidityHistory = [];
    const MAX_HISTORY = 100;
    let heatmapEnabled = false;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    let clustersVisible = false;
    let currentMarkers = [];
    let currentPriceLines = [];
    let heatmapCanvas = null;    
    let glassmapDensity = {};

    let lastHeaderPrice = null;

    // üî• AGREGAR ESTAS 3 L√çNEAS PARA HISTORIAL DIARIO
    // =====================================================
    // üìÖ SISTEMA DE HISTORIAL DIARIO
    // =====================================================
    let dailyZonesHistory = JSON.parse(localStorage.getItem(`dailyZonesHistory_${symbol}`)) || {};
    let autoSaveInterval = null;
    let lastAutoSave = Date.now();

    function recordGlassmapLiquidity(price, usdt) {
        glassmapDensity[price] = (glassmapDensity[price] || 0) + usdt;
    }

    // =====================================================
    // üî• NUEVO MANAGER DE WEBSOCKETS (VERSI√ìN SIMPLIFICADA)
    // =====================================================

    class BinanceWebSocketManager {
        constructor(symbol = 'BTCUSDT') {
            this.symbol = symbol.toLowerCase();
            this.wsInstances = new Map();
        }

        // CONECTAR TODOS
        connectAll(interval = '1h') {
            this.connectTicker();
            this.connectMarkPrice();
            this.connectDepth();
            this.connectKline(interval);
        }

        // TICKER
        connectTicker() {
            const wsUrl = `wss://fstream.binance.com/ws/${this.symbol}@ticker`;
            this.createWebSocket('ticker', wsUrl, (event) => {
                try {
                    const data = JSON.parse(event.data);
                    const now = Date.now();

                    if (data.c !== undefined) {
                        let newPrice = Number(data.c);
                        const cambio24h = data.P ? Number(data.P) : 0;

                        markPriceFutures = newPrice;
                        lastPriceUpdate = now;

                        updateHeaderPrice(newPrice, cambio24h);
                        updateTimestamp();
                        scheduleTableUpdate();
                        updateMarketSpread();
                    }
                } catch (err) {
                    console.error('Error en ticker:', err);
                }
            });
        }

        // MARK PRICE
        connectMarkPrice() {
            const wsUrl = `wss://fstream.binance.com/ws/${this.symbol}@markPrice@1s`;
            this.createWebSocket('markPrice', wsUrl, (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.s === this.symbol.toUpperCase()) {
                        const newPrice = parseFloat(data.p);
                        
                        markPriceFutures = newPrice;
                        lastPriceUpdate = Date.now();
                        
                        updateMarketSpread();
                    }
                } catch (err) {
                    console.error('Error en mark price:', err);
                }
            });
        }

        // DEPTH
        connectDepth() {
            const wsUrl = `wss://fstream.binance.com/ws/${this.symbol}@depth@100ms`;
            this.createWebSocket('depth', wsUrl, (event) => {
                try {
                    const data = JSON.parse(event.data);
                    const now = Date.now();

                    // ASKS
                    if (data.a && Array.isArray(data.a) && data.a.length > 0) {
                        futuresAsksData = updateOrders(futuresAsksData, data.a, now, true);
                        asksProcessed += data.a.length;

                        data.a.forEach(([p, q]) => {
                            const price = parseFloat(p);
                            const quantity = parseFloat(q);
                            const usdtValue = price * quantity;

                            procesarLiquidez(price, quantity, true);
                            recordGlassmapLiquidity(price, usdtValue);

                            if (usdtValue >= VERY_LARGE_ORDER_THRESHOLD) {
                                showOrderAlert('ask', usdtValue, true);
                            } else if (usdtValue >= LARGE_ORDER_THRESHOLD) {
                                showOrderAlert('ask', usdtValue, false);
                            }
                        });
                    }

                    // BIDS
                    if (data.b && Array.isArray(data.b) && data.b.length > 0) {
                        futuresBidsData = updateOrders(futuresBidsData, data.b, now, false);
                        bidsProcessed += data.b.length;

                        data.b.forEach(([p, q]) => {
                            const price = parseFloat(p);
                            const quantity = parseFloat(q);
                            const usdtValue = price * quantity;

                            procesarLiquidez(price, quantity, false);
                            recordGlassmapLiquidity(price, usdtValue);

                            if (usdtValue >= VERY_LARGE_ORDER_THRESHOLD) {
                                showOrderAlert('bid', usdtValue, true);
                            } else if (usdtValue >= LARGE_ORDER_THRESHOLD) {
                                showOrderAlert('bid', usdtValue, false);
                            }
                        });
                    }

                    updateProcessedCounters();
                    updateLiquidityStats();
                    updateOrderBookImbalance();
                    eliminarZonasTocadas(markPriceFutures);
                    dibujarZonasSMC();

                } catch (err) {
                    console.error('Error en depth:', err);
                }
            });
        }

        // KLINE
        connectKline(interval = '1h') {
            const validIntervals = ['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h', '6h', '8h', '12h', '1d', '3d', '1w', '1M'];
            const cleanInterval = validIntervals.includes(interval) ? interval : '1h';
            
            const wsUrl = `wss://fstream.binance.com/ws/${this.symbol}@kline_${cleanInterval}`;
            
            this.createWebSocket('kline', wsUrl, (event) => {
                try {
                    const data = JSON.parse(event.data);
                    const kline = data.k;
                    
                    const newCandle = {
                        time: Math.floor(kline.t / 1000),
                        open: parseFloat(kline.o),
                        high: parseFloat(kline.h),
                        low: parseFloat(kline.l),
                        close: parseFloat(kline.c)
                    };
                    
                    if (kline.x) {
                        if (candlesData.length > 0 && candlesData[candlesData.length - 1].time === newCandle.time) {
                            candlesData[candlesData.length - 1] = newCandle;
                        } else {
                            candlesData.push(newCandle);
                            if (candlesData.length > 1000) candlesData.shift();
                        }
                        lastCandle = newCandle;
                    } else {
                        if (candlesData.length > 0 && candlesData[candlesData.length - 1].time === newCandle.time) {
                            candlesData[candlesData.length - 1] = newCandle;
                        } else if (candlesData.length === 0 || newCandle.time > candlesData[candlesData.length - 1].time) {
                            candlesData.push(newCandle);
                            if (candlesData.length > 1000) candlesData.shift();
                        }
                    }
                    
                    if (candlestickSeries) {
                        candlestickSeries.setData(candlesData);
                        
                        const ema100 = calculateEMA(candlesData, 100);
                        if (emaSeries) {
                            emaSeries.setData(ema100);
                        }
                    }
                    
                } catch (err) {
                    console.error('Error en kline:', err);
                }
            }, true); // kline necesita reconexi√≥n especial
        }

        // CREAR WEBSOCKET CON RECONEXI√ìN
        createWebSocket(type, url, onMessageHandler, isKline = false) {
            // Cerrar anterior si existe
            const oldWs = this.wsInstances.get(type);
            if (oldWs) oldWs.close();

            const ws = new WebSocket(url);
            let reconnectAttempt = 0;

            ws.onopen = () => {
                console.log(`‚úÖ ${type} conectado`);
                reconnectAttempt = 0;
                updateWsStatus(`${type}: Conectado`);
                
                if (type === 'kline') {
                    loadHistoricalKlines();
                }
            };

            ws.onmessage = onMessageHandler;

            ws.onerror = (error) => {
                console.error(`‚ùå ${type} error:`, error);
            };

            ws.onclose = (event) => {
                console.log(`üîå ${type} cerrado`);
                
                // Reconectar autom√°ticamente
                setTimeout(() => {
                    if (reconnectAttempt < 5) {
                        reconnectAttempt++;
                        console.log(`üîÑ Reintentando ${type}...`);
                        this.createWebSocket(type, url, onMessageHandler, isKline);
                    }
                }, 3000);
            };

            // Guardar referencia
            this.wsInstances.set(type, ws);
        }

        // DESCONECTAR TODO
        disconnectAll() {
            this.wsInstances.forEach(ws => {
                if (ws.readyState !== WebSocket.CLOSED) {
                    ws.close();
                }
            });
            this.wsInstances.clear();
        }
    }

    // Variable global del manager
    let wsManager = null;

    // =====================================================
    // üîß FUNCIONES NECESARIAS PARA EL MANAGER
    // =====================================================

    // 1. Reemplazar initializeWebSockets
    function initializeWebSockets() {
        if (wsManager) {
            wsManager.disconnectAll();
        }
        
        wsManager = new BinanceWebSocketManager(symbol);
        wsManager.connectAll(currentInterval);
        initializeChart();
    }

    function changeChartInterval() {
        const newInterval = document.getElementById("interval-select").value;
        if (newInterval === currentInterval) return;
        
        // Cambiar intervalo
        currentInterval = newInterval;
        localStorage.setItem('chartInterval', currentInterval);
        
        // Vaciar gr√°fico inmediatamente
        candlesData = [];
        if (candlestickSeries) candlestickSeries.setData([]);
        if (emaSeries) emaSeries.setData([]);
        
        // Cambiar WebSocket (CORREGIDO - sin initializeKlineSocket)
        if (wsManager) {
            wsManager.connectKline(currentInterval);
        }
        
        // Cargar hist√≥rico sin bloquear
        setTimeout(() => {
            loadHistoricalKlines().then(() => {
                // Sin mensajes
            }).catch(() => {
                // Error silencioso
            });
        }, 50);
    }

    // 3. Bot√≥n de reconexi√≥n
    function addReconnectButton() {
        const headerCenter = document.querySelector('.header-center');
        if (headerCenter && !document.getElementById('reconnect-btn')) {
            const btn = document.createElement('button');
            btn.id = 'reconnect-btn';
            btn.innerHTML = 'üîÑ';
            btn.title = 'Reconectar WebSockets';
            btn.style.cssText = `
                margin-left: 10px;
                padding: 2px 6px;
                font-size: 10px;
                cursor: pointer;
                background: #444;
                border: 1px solid #666;
                color: white;
                border-radius: 3px;
            `;
            btn.onclick = () => {
                if (wsManager) {
                    showError("Reconectando...");
                    wsManager.disconnectAll();
                    setTimeout(() => {
                        wsManager.connectAll(currentInterval);
                        clearError();
                    }, 1000);
                }
            };
            headerCenter.appendChild(btn);
        }
    }

    function glassColor(v) {
        v = Math.min(Math.max(v, 0), 1);
        const r = Math.floor(255 * v);
        const g = Math.floor(200 * (1 - v));
        const b = 180;
        return `rgb(${r},${g},${b})`;
    }

        // ==============================
    // üîî SISTEMA DE ALERTAS GLOBAL
    // ==============================
    let ALERT_SETTINGS = {
        soundEnabled: true,   // sonido ON/OFF
        spreadAlert: 0.10,    // 0.10% de spread
        imbalanceAlert: 20,   // 20% desequilibrio
        volumeAlert: 80_000_000 // 80M de liquidez
    };   
 
   
    // =====================================================
    // üîπ CONVERTIR PRECIO ‚Üí COORDENADA Y (FUNCIONA SIEMPRE)
    // =====================================================
    function priceToY_Pro(price) {
        if (!candlestickSeries) return null;
        const y = candlestickSeries.priceToCoordinate(price);
        return (y !== undefined && y !== null) ? y : null;
    }

        // =====================================================
    // üî• GLASSMAP ‚Äî Heatmap horizontal tipo Coinglass
    // =====================================================

    function drawHeatmapGlass() {
        if (!heatmapEnabled) return;

        const ctx = heatmapCanvas.getContext("2d");
        const w = heatmapCanvas.width;
        const h = heatmapCanvas.height;

        // üîπ 1) Mover todo el heatmap 1px a la izquierda (scroll)
        const img = ctx.getImageData(1, 0, w - 1, h);
        ctx.clearRect(0, 0, w, h);
        ctx.putImageData(img, 0, 0);

        // üîπ 2) Columna nueva en la derecha
        const x = w - 1;

        Object.keys(glassmapDensity).forEach(price => {
            const y = candlestickSeries.priceToCoordinate(parseFloat(price));
            if (!y) return;

            // Normalizaci√≥n de intensidad
            const intensity = Math.min(glassmapDensity[price] / 30000000, 1);

            ctx.fillStyle = glassColor(intensity);

            // Grosor de la l√≠nea
            ctx.fillRect(x, y - 1, 1, 2);
        });

        // üîÅ Loop de animaci√≥n
        requestAnimationFrame(drawHeatmapGlass);
    }

    function recordGlassmapLiquidity(price, usdt) {
        if (!glassmapDensity[price]) glassmapDensity[price] = 0;
        glassmapDensity[price] += usdt;

        if (Object.keys(glassmapDensity).length > 4000) {
            glassmapDensity = {};
        }
    }


    // =====================================================
    // üîò BOT√ìN ON/OFF PROFESIONAL (NO SE ROMPE NUNCA)
    // =====================================================

    function toggleHeatmapPro() {
        heatmapEnabled = !heatmapEnabled;

        const btn = document.querySelector('button[onclick="toggleHeatmapPro()"]');

        if (heatmapEnabled) {
            console.log("üî• GLASSMAP ACTIVADO");

            resizeHeatmapCanvas();   // ‚Üê CORREGIDO

            requestAnimationFrame(drawHeatmapGlass);

            if (btn) {
                btn.textContent = "üî• Heatmap ON (Glassmap)";
                btn.classList.remove("heatmap-off");
                btn.classList.add("heatmap-on");
            }

        } else {
            console.log("‚ùå GLASSMAP DESACTIVADO");

            const ctx = heatmapCanvas.getContext("2d", { willReadFrequently: true });
            ctx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);

            if (btn) {
                btn.textContent = "‚ùå Heatmap OFF";
                btn.classList.remove("heatmap-on");
                btn.classList.add("heatmap-off");
            }
        }
    }

    // =====================================================
    // üìà TRACKING DE LIQUIDEZ (OPTIMIZADO)
    // =====================================================

    // Elementos del DOM
    const errorMessageElement = document.getElementById("error-message");
    
    // Cargar precios seleccionados desde localStorage
    function loadSelectedPrices() {
      const savedPrices = JSON.parse(localStorage.getItem(`selectedPrices_${symbol}`) || '[]');
      selectedPrices.clear();
      savedPrices.forEach(price => selectedPrices.set(price, { series: null, isAsk: false }));
    }   
  
 

    function updateHeaderPrice(price, change24h) {
        const priceEl = document.getElementById('hdr-price');
        const changeEl = document.getElementById('hdr-change');
        const symbolEl = document.getElementById('hdr-symbol');

        if (!priceEl || !changeEl || !symbolEl) return;

        // s√≠mbolo fijo
        symbolEl.textContent = symbol;

        // detectar tick
        let direction = null;
        if (lastHeaderPrice !== null) {
            if (price > lastHeaderPrice) direction = 'up';
            else if (price < lastHeaderPrice) direction = 'down';
        }
        lastHeaderPrice = price;

        // actualizar precio
        priceEl.textContent = `$${price.toLocaleString('en-US', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        })}`;

        // reset clases
        priceEl.classList.remove('up', 'down');
        if (direction) priceEl.classList.add(direction);

        // % 24h REAL (ticker)
        const isUp24 = change24h >= 0;
        changeEl.textContent = `${isUp24 ? '‚ñ≤' : '‚ñº'} ${Math.abs(change24h).toFixed(2)}%`;
        changeEl.style.color = isUp24 ? '#4eff78' : '#ff5555';
    }
    // ============================================
// üî• CALCULAR CAMBIO EN TIEMPO REAL
// ============================================
    let lastRealPrice = 0;
    let priceHistory = [];

  


    
    // Mostrar alerta visual para √≥rdenes institucionales
    function showOrderAlert(type, value, isVeryLarge) {
      const panelTitle = document.querySelector(`.${type}s-title`);
      if (!panelTitle) return;
      
      const panel = panelTitle.closest('.panel');
      if (!panel) return;
      
      const alertElement = document.createElement('div');
      alertElement.className = `panel-alert ${type}-alert`;
      alertElement.textContent = `${type === 'ask' ? 'SELL' : 'BUY'}: ${formatUsdt(value)}`;
      
      panel.appendChild(alertElement);
      
      if (lastAlertElement && lastAlertElement.parentNode) {
        lastAlertElement.remove();
      }
      
      lastAlertElement = alertElement;
      
      if (ALERT_SETTINGS.soundEnabled) {
        playAlertSound(isVeryLarge ? 'volume' : 'default');
      }
      
      setTimeout(() => {
        if (alertElement && alertElement.parentNode) {
          alertElement.remove();
        }
      }, 5000);
      
      if (isVeryLarge && chart) {
        const price = type === 'ask' 
          ? futuresAsksData.find(a => a.usdt === value)?.price 
          : futuresBidsData.find(b => b.usdt === value)?.price;
        
        if (price) {
          addChartAlertMarker(price, type, value);
        }
      }
    }
    
    // A√±adir marcador de alerta al gr√°fico
    function addChartAlertMarker(price, type, value) {
      if (!candlestickSeries) return;
      
      const now = Math.floor(Date.now() / 1000);
      const marker = {
        time: now,
        position: type === 'ask' ? 'belowBar' : 'aboveBar',
        color: type === 'ask' ? '#ff0000' : '#00ff00',
        shape: type === 'ask' ? 'arrowDown' : 'arrowUp',
        text: `${type.toUpperCase()}: $${formatUsdt(value)}`,
        size: 2
      };
      
      candlestickSeries.setMarkers([marker]);
      
      setTimeout(() => {
        candlestickSeries.setMarkers([]);
      }, 30000);
    }
    
    // Actualizar √≥rdenes con nuevos datos
    function updateOrders(existingOrders, newOrders, now, isAsk) {
      const orderMap = new Map(existingOrders.map(o => [o.price, o]));
      
      newOrders.forEach(([p, q]) => {
        const price = parseFloat(p);
        const quantity = parseFloat(q);
        const usdtValue = price * quantity;
        
        if (quantity === 0) {
          orderMap.delete(price);
          rowColors.delete(price);
        } else {
          const existingOrder = orderMap.get(price);
          
          if (existingOrder) {
            existingOrder.qty = quantity;
            existingOrder.usdt = usdtValue;
            existingOrder.lastUpdated = now;
            existingOrder.hits = (existingOrder.hits || 0) + 1;
            existingOrder.colorAssignedTime = now;
          } else {
            orderMap.set(price, {
              price: price,
              qty: quantity,
              usdt: usdtValue,
              lastUpdated: now,
              colorAssignedTime: now,
              hits: 1
            });
          }
        }
      });
      
      return Array.from(orderMap.values())
        .filter(order => order.usdt > 100)
        .sort((a, b) => b.usdt - a.usdt)
        .slice(0, 20);
    }
    
    // Actualizar tablas de bids y asks
    function updateTables() {
      updateTable("asks-body", futuresAsksData, true);
      updateTable("bids-body", futuresBidsData, false);
    }
    
    // Actualizar una tabla espec√≠fica (versi√≥n simplificada)
    function updateTable(tableId, data, isAsk) {
      const tableBody = document.getElementById(tableId);
      if (!tableBody) return;
      
      const now = Date.now();
      const existingRows = new Map();
      
      Array.from(tableBody.children).forEach(row => {
        const priceCell = row.querySelector('.price-cell');
        if (priceCell) {
          const price = parseFloat(priceCell.textContent);
          existingRows.set(price, row);
        }
      });
      
      const fragment = document.createDocumentFragment();
      
      data.forEach((item, index) => {
        const age = formatAge(now - item.lastUpdated);
        const percentage = markPriceFutures ? 
          (((item.price - markPriceFutures) / markPriceFutures) * 100).toFixed(3) + "%" : 
          "---";
        
        let row = existingRows.get(item.price);
        
        if (!row) {
          row = document.createElement("tr");
          row.className = isAsk ? "ask-row" : "bid-row";
        }
        
        // Solo negrita para las top 5
        if (index < 5) {
          row.classList.add("bold-row");
        } else {
          row.classList.remove("bold-row");
        }
        
        // Color morado solo para √≥rdenes institucionales
        if (item.usdt >= LARGE_ORDER_THRESHOLD) {
          row.classList.add("color-purple");
          row.classList.add("bold-row");
        } else {
          row.classList.remove("color-purple");
        }
        
        const recentlyUpdated = item.lastUpdated && (now - item.lastUpdated) <= 1000;
        if (recentlyUpdated) {
          const highlightClass = isAsk ? "highlight-red" : "highlight-green";
          row.classList.remove("highlight-red", "highlight-green");
          row.classList.add(highlightClass);
          
          setTimeout(() => {
            row.classList.remove("highlight-red", "highlight-green");
            if (item.usdt >= LARGE_ORDER_THRESHOLD) {
              row.classList.add("color-purple");
              row.classList.add("bold-row");
            }
          }, 1000);
        }
        
        const isSelected = selectedPrices.has(item.price);
        if (isSelected) {
          row.classList.remove("selected-row");
        } else {
          row.classList.remove("selected-row");
        }
        
        row.innerHTML = `
          <td><span>${index + 1}</span></td>
          <td class="age-cell"><span>${age}</span></td>
          <td class="price-cell"><span>${formatPrice(item.price)}</span></td>
          <td><span>${formatQuantity(item.qty)}</span></td>
          <td><span>${formatUsdt(item.usdt)}</span></td>
          <td><span>${percentage}</span></td>
          <td><span>${item.hits}</span></td>
          <td class="selected-column">
            <input type="checkbox" class="selection-checkbox" ${isSelected ? 'checked' : ''} 
            onchange="togglePriceSelection(${item.price}, ${isAsk}, this)"
            aria-label="${isSelected ? 'Deseleccionar' : 'Seleccionar'} precio ${formatPrice(item.price)}">
          </td>
        `;
        
        fragment.appendChild(row);
        existingRows.delete(item.price);
      });
      
      existingRows.forEach(row => {
        const priceCell = row.querySelector('.price-cell');
        if (priceCell) {
          const price = parseFloat(priceCell.textContent);
          rowColors.delete(price);
        }
        row.remove();
      });
      
      tableBody.innerHTML = '';
      tableBody.appendChild(fragment);
      
      redrawSelectedLines();
    }
    
    // Funci√≥n simplificada para colores
    function getColorClass(item, now) {
      if (item.usdt >= LARGE_ORDER_THRESHOLD) {
        return "color-purple";
      }
      return "color-transparent";
    }
    
    // Programar actualizaci√≥n de tablas con debounce
    function scheduleTableUpdate() {
      if (!pendingUpdate && !updatePaused) {
        pendingUpdate = true;
        setTimeout(() => {
          updateTables();
          pendingUpdate = false;
        }, 100);
      }
    }

    // Funciones de manejo de interacci√≥n
    function startInteraction() {
      isInteracting = true;
      updatePaused = true;
    }

    function endInteraction() {
      isInteracting = false;
      updatePaused = false;
      scheduleTableUpdate();
    }
    
    // Actualizar contadores de √≥rdenes procesadas
    function updateProcessedCounters() {
        const totalPrices = asksProcessed + bidsProcessed;
        
        document.getElementById("total-prices").innerText = totalPrices.toLocaleString();
        document.getElementById("asks-processed").innerText = asksProcessed.toLocaleString();
        document.getElementById("bids-processed").innerText = bidsProcessed.toLocaleString();
        
        if (totalPrices >= 1000000) {
            document.getElementById("total-prices").classList.add("highlight-total");
        } else {
            document.getElementById("total-prices").classList.remove("highlight-total");
        }
        
        const askIndicatorStart = document.getElementById("asks-indicator-start");
        const askIndicatorEnd = document.getElementById("asks-indicator-end");
        const bidIndicatorStart = document.getElementById("bids-indicator-start");
        const bidIndicatorEnd = document.getElementById("bids-indicator-end");
        
        if (askIndicatorStart && askIndicatorEnd && bidIndicatorStart && bidIndicatorEnd) {
            askIndicatorStart.classList.remove("circle-red", "circle-green");
            askIndicatorEnd.classList.remove("circle-red", "circle-green");
            bidIndicatorStart.classList.remove("circle-red", "circle-green");
            bidIndicatorEnd.classList.remove("circle-red", "circle-green");
            
            if (asksProcessed > bidsProcessed) {
                askIndicatorStart.classList.add("circle-red");
                askIndicatorEnd.classList.add("circle-red");
            } else if (bidsProcessed > asksProcessed) {
                bidIndicatorStart.classList.add("circle-green");
                bidIndicatorEnd.classList.add("circle-green");
            }
        }
        
        scheduleTableUpdate();
        
        // ‚úÖ A√ëADE ESTA L√çNEA AL FINAL DE LA FUNCI√ìN:
        //updateSymbolInfoDisplay(markPriceFutures || 0, 0, totalPrices);
    }
    
    // Actualizar estad√≠sticas de liquidez
    function updateLiquidityStats() {
      const totalAskLiquidity = futuresAsksData.reduce((sum, order) => sum + order.usdt, 0);
      const totalBidLiquidity = futuresBidsData.reduce((sum, order) => sum + order.usdt, 0);
      
      const largeAsksCount = futuresAsksData.filter(order => order.usdt >= LARGE_ORDER_THRESHOLD).length;
      const largeBidsCount = futuresBidsData.filter(order => order.usdt >= LARGE_ORDER_THRESHOLD).length;
      
      document.getElementById("total-ask-liquidity").textContent = formatUsdt(totalAskLiquidity);
      document.getElementById("total-bid-liquidity").textContent = formatUsdt(totalBidLiquidity);
      document.getElementById("large-asks-count").textContent = largeAsksCount;
      document.getElementById("large-bids-count").textContent = largeBidsCount;
    }
    
    // Calcular y mostrar desequilibrio del libro de √≥rdenes
    function updateOrderBookImbalance() {
      const totalBidLiquidity = futuresBidsData.reduce((sum, order) => sum + order.usdt, 0);
      const totalAskLiquidity = futuresAsksData.reduce((sum, order) => sum + order.usdt, 0);
      const totalLiquidity = totalBidLiquidity + totalAskLiquidity;
      
      if (totalLiquidity > 0) {
        const imbalance = ((totalBidLiquidity - totalAskLiquidity) / totalLiquidity) * 100;
        document.getElementById("orderbook-imbalance").textContent = `${imbalance.toFixed(2)}%`;
        
        const indicator = document.getElementById("imbalance-indicator");
        if (indicator) {
          const position = (imbalance + 100) / 2;
          indicator.style.left = `${position}%`;
        }
      }
    }
    
    // Actualizar spread del mercado
    function updateMarketSpread() {
      if (futuresBidsData.length > 0 && futuresAsksData.length > 0 && markPriceFutures > 0) {
        const bestBid = futuresBidsData[0].price;
        const bestAsk = futuresAsksData[0].price;
        const spread = bestAsk - bestBid;
        const spreadPercentage = (spread / markPriceFutures) * 100;
        
        document.getElementById("market-spread").textContent = `${formatPrice(spread)} (${spreadPercentage.toFixed(3)}%)`;
        document.getElementById("best-bid-ask").textContent = `${formatPrice(bestBid)} / ${formatPrice(bestAsk)}`;
      }
    }   

    
    // Mostrar clusters de liquidez
    function showLiquidityClusters() {
      if (liquidityHistory.length < 3) return;

      const priceLevels = {};
      const priceStep = markPriceFutures * 0.002; // Agrupa precios dentro del 0.2%

      liquidityHistory.slice(-10).forEach(snapshot => {
        [...snapshot.bids, ...snapshot.asks].forEach(order => {
          const roundedPrice = (Math.round(order.price / priceStep) * priceStep).toFixed(2);
          if (!priceLevels[roundedPrice]) {
            priceLevels[roundedPrice] = {
              totalUsdt: 0,
              count: 0,
              type: order.price <= markPriceFutures ? 'bid' : 'ask'
            };
          }
          priceLevels[roundedPrice].totalUsdt += order.usdt;
          priceLevels[roundedPrice].count++;
        });
      });

      const significantClusters = Object.entries(priceLevels)
        .filter(([_, data]) => data.totalUsdt >= LARGE_ORDER_THRESHOLD * 0.5)
        .sort((a, b) => b[1].totalUsdt - a[1].totalUsdt);

      drawClustersOnChart(significantClusters);
    }
    
    // Funci√≥n para dibujar clusters en el gr√°fico
    function drawClustersOnChart(clusters) {
      clearClusters();
      if (!chart || !candlestickSeries || !markPriceFutures) return;

      // Agrupar clusters cercanos para evitar saturaci√≥n
      const groupedClusters = groupNearbyClusters(clusters);
      
      // Limpiar l√≠neas anteriores
      currentPriceLines.forEach(line => {
        try {
          chart.removeSeries(line.series);
        } catch (err) {
          console.warn(`Error al remover serie: ${err.message}`);
        }
      });
      currentPriceLines = [];
      
      // Enfocarnos solo en las zonas de mayor volumen cercanas al precio actual
      const currentPriceThreshold = markPriceFutures * 0.05; // ¬±5% del precio actual
      const filteredClusters = groupedClusters.filter(cluster => 
        Math.abs(cluster.avgPrice - markPriceFutures) <= currentPriceThreshold
      );
      
      // Ordenar por volumen descendente y tomar solo los 3 m√°s grandes
      const topClusters = filteredClusters
        .sort((a, b) => b.totalUsdt - a.totalUsdt)
        .slice(0, 3);
      
      // Dibujar l√≠neas horizontales para los clusters
      const now = Math.floor(Date.now() / 1000);
      
      topClusters.forEach(cluster => {
        const isBid = cluster.type === 'bid';
        const lineSeries = chart.addLineSeries({
          color: isBid ? 'rgba(255, 0, 255, 1)' : 'rgba(255, 0, 255, 1)', // Verde claro para bids, rojo claro para asks
          lineWidth: 2, // L√≠nea m√°s fina
          priceLineVisible: false,
          lastValueVisible: false,
          lineStyle: LightweightCharts.LineStyle.Solid
        });
        
        // L√≠nea en todo el gr√°fico
        lineSeries.setData([
          { time: now - 86400, value: cluster.avgPrice }, // 1 d√≠a atr√°s
          { time: now, value: cluster.avgPrice }
        ]);
        
        // Agregar etiqueta de precio
        const priceLine = {
          price: cluster.avgPrice,
          color: isBid ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)',
          lineWidth: 1,
          lineStyle: LightweightCharts.LineStyle.Solid,
          title: `${formatPrice(cluster.avgPrice)} | ${formatUsdt(cluster.totalUsdt)}`,
          axisLabelVisible: true,
          axisLabelColor: isBid ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)',
          axisLabelTextColor: '#ffffff'
        };
        
        lineSeries.createPriceLine(priceLine);
        currentPriceLines.push({ series: lineSeries, price: cluster.avgPrice });
      });
    }

    // Modificaci√≥n para el hover del checkbox
    function setupEventListeners() {
      const asksBody = document.getElementById("asks-body");
      const bidsBody = document.getElementById("bids-body");
      
      if (asksBody) {
        asksBody.addEventListener('click', handleTableClick);
        asksBody.addEventListener('mouseover', (e) => {
          const checkbox = e.target.closest('.selected-column input[type="checkbox"]');
          if (checkbox) {
            checkbox.style.pointerEvents = 'auto'; // Permitir interacci√≥n con el checkbox
          }
        });
      }
      
      if (bidsBody) {
        bidsBody.addEventListener('click', handleTableClick);
        bidsBody.addEventListener('mouseover', (e) => {
          const checkbox = e.target.closest('.selected-column input[type="checkbox"]');
          if (checkbox) {
            checkbox.style.pointerEvents = 'auto'; // Permitir interacci√≥n con el checkbox
          }
        });
      }
      
      document.getElementById('symbol-search').addEventListener('change', (e) => {
        const selectedSymbol = e.target.value.toUpperCase();
        if (selectedSymbol) {
          window.location.href = `?symbol=${selectedSymbol}`;
        }
      });
      
      document.getElementById('interval-select').addEventListener('change', changeChartInterval);
      
      window.addEventListener('resize', () => {
        if (chart) {
          chart.resize(document.getElementById("chart-container").offsetWidth, 400);
          redrawSelectedLines();
        }
      });
    }

    // Agrupa clusters cercanos para evitar saturaci√≥n visual
    function groupNearbyClusters(clusters) {
      if (clusters.length === 0) return [];
      
      const priceStep = markPriceFutures * 0.002; // Agrupa precios dentro del 0.2%
      const grouped = [];
      
      // Ordenar por precio
      clusters.sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));
      
      let currentGroup = null;
      
      clusters.forEach(([price, data]) => {
        const priceNum = parseFloat(price);
        
        if (!currentGroup || priceNum - currentGroup.maxPrice > priceStep) {
          // Nuevo grupo
          currentGroup = {
            prices: [priceNum],
            totalUsdt: data.totalUsdt,
            count: 1,
            type: data.type,
            minPrice: priceNum,
            maxPrice: priceNum
          };
          grouped.push(currentGroup);
        } else {
          // Agregar al grupo existente
          currentGroup.prices.push(priceNum);
          currentGroup.totalUsdt += data.totalUsdt;
          currentGroup.count++;
          currentGroup.maxPrice = priceNum;
        }
      });
      
      // Calcular promedio para cada grupo
      return grouped.map(group => ({
        avgPrice: group.prices.reduce((sum, p) => sum + p, 0) / group.prices.length,
        totalUsdt: group.totalUsdt,
        type: group.type,
        count: group.count
      }));
    }

    // Funci√≥n para limpiar clusters
    function clearClusters() {
      if (candlestickSeries) candlestickSeries.setMarkers([]);
      currentMarkers = [];
      
      currentPriceLines.forEach(line => {
        try {
          chart.removeSeries(line.series);
        } catch (err) {
          console.warn(`Error al remover serie: ${err.message}`);
        }
      });
      currentPriceLines = [];
    }

    // Funci√≥n para alternar clusters
    function toggleClusters() {
      clustersVisible = !clustersVisible;
      const button = document.getElementById('cluster-toggle');
      button.textContent = clustersVisible ? '‚ùå Ocultar Clusters' : 'üìä Mostrar Clusters';
      
      if (clustersVisible) {
        showLiquidityClusters();
      } else {
        clearClusters();
      }
    }
    
        
    // Guardar niveles clave
    function saveKeyLevels() {
      const keyLevels = {
        bids: futuresBidsData.filter(b => b.usdt >= LARGE_ORDER_THRESHOLD),
        asks: futuresAsksData.filter(a => a.usdt >= LARGE_ORDER_THRESHOLD),
        timestamp: Date.now()
      };
      
      localStorage.setItem(`keyLevels_${symbol}`, JSON.stringify(keyLevels));
      showAlert(`Niveles clave guardados para ${symbol}`, 'volume');
    }
    
    // Actualizar umbrales de √≥rdenes grandes
    function updateThresholds() {
      const largeThresholdInput = document.getElementById("large-threshold");
      const veryLargeThresholdInput = document.getElementById("very-large-threshold");
      
      if (largeThresholdInput && veryLargeThresholdInput) {
        LARGE_ORDER_THRESHOLD = parseFloat(largeThresholdInput.value) || 50000000;
        VERY_LARGE_ORDER_THRESHOLD = parseFloat(veryLargeThresholdInput.value) || 100000000;
        
        updateTables();
        showAlert(`Umbrales actualizados: ${formatUsdt(LARGE_ORDER_THRESHOLD)} / ${formatUsdt(VERY_LARGE_ORDER_THRESHOLD)}`, 'volume');
      }
    }
    
    // Alternar alertas de sonido
    function toggleSoundAlerts() {
      ALERT_SETTINGS.soundEnabled = !ALERT_SETTINGS.soundEnabled;
      localStorage.setItem('alertSettings', JSON.stringify(ALERT_SETTINGS));
      
      const soundToggle = document.getElementById("sound-toggle");
      if (soundToggle) {
        soundToggle.textContent = ALERT_SETTINGS.soundEnabled ? "üîä Sonido: ON" : "üîá Sonido: OFF";
      }
    }
    
    // Inicializar sistema de alertas
    function initAlerts() {
      const savedSettings = localStorage.getItem('alertSettings');
      if (savedSettings) {
        Object.assign(ALERT_SETTINGS, JSON.parse(savedSettings));
      }
      
      const soundToggle = document.getElementById("sound-toggle");
      if (soundToggle) {
        soundToggle.textContent = ALERT_SETTINGS.soundEnabled ? "üîä Sonido: ON" : "üîá Sonido: OFF";
      }
      
      setInterval(checkAlerts, 10000);
    }
    
    // Verificar condiciones para alertas
    function checkAlerts() {
      if (!markPriceFutures || futuresBidsData.length === 0 || futuresAsksData.length === 0) return;
      
      const spreadText = document.getElementById('market-spread').textContent;
      const spreadMatch = spreadText.match(/\(([\d.]+)%\)/);
      if (spreadMatch) {
        const spread = parseFloat(spreadMatch[1]);
        if (spread > ALERT_SETTINGS.spreadAlert) {
          showAlert(`Spread alto: ${spread.toFixed(2)}%`, 'spread');
        }
      }
      
      const imbalanceText = document.getElementById('orderbook-imbalance').textContent;
      const imbalance = parseFloat(imbalanceText);
      if (Math.abs(imbalance) > ALERT_SETTINGS.imbalanceAlert) {
        const direction = imbalance > 0 ? "COMPRA" : "VENTA";
        showAlert(`Desequilibrio extremo (${direction}): ${Math.abs(imbalance).toFixed(2)}%`, 'imbalance');
      }
      
      const bidLiquidityText = document.getElementById('total-bid-liquidity').textContent;
      const askLiquidityText = document.getElementById('total-ask-liquidity').textContent;
      
      const bidLiquidity = parseFloat(bidLiquidityText.replace(/[^0-9.]/g, ''));
      const askLiquidity = parseFloat(askLiquidityText.replace(/[^0-9.]/g, ''));
      
      if (bidLiquidity > ALERT_SETTINGS.volumeAlert) {
        showAlert(`Liquidez BID inusual: ${formatUsdt(bidLiquidity)}`, 'volume');
      }
      
      if (askLiquidity > ALERT_SETTINGS.volumeAlert) {
        showAlert(`Liquidez ASK inusual: ${formatUsdt(askLiquidity)}`, 'volume');
      }
    }
    
    // Mostrar alerta en el sistema
    function showAlert(message, type) {
      const existingAlerts = document.querySelectorAll('.market-alert');
      for (const alert of existingAlerts) {
        if (alert.textContent.includes(message.substring(0, 20))) {
          return;
        }
      }
      
      const alertDiv = document.createElement('div');
      alertDiv.className = `market-alert ${type}-alert`;
      alertDiv.innerHTML = `
        <span class="alert-time">${new Date().toLocaleTimeString()}</span>
        <span class="alert-message">${message}</span>
        <button class="alert-close" onclick="this.parentElement.remove()">&times;</button>
      `;
      
      document.getElementById('alert-container').prepend(alertDiv);
      
      if (ALERT_SETTINGS.soundEnabled) {
        playAlertSound(type);
      }
      
      setTimeout(() => {
        if (alertDiv.parentNode) {
          alertDiv.remove();
        }
      }, 60000);
    }
    
    // Reproducir sonido de alerta
    function playAlertSound(type) {
      // Implementaci√≥n b√°sica - puedes mejorarla con sonidos personalizados
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        oscillator.type = 'sine';
        oscillator.frequency.value = type === 'volume' ? 880 : 440;
        gainNode.gain.value = 0.1;
        
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        oscillator.start();
        setTimeout(() => {
          oscillator.stop();
        }, 300);
      } catch (e) {
        console.log('Error al reproducir sonido:', e);
      }
    }  
   
       // =====================================================
    // ‚≠ê SISTEMA DE CANVAS HEATMAP PROFESIONAL (Glassmap)
    // =====================================================
    function setupHeatmapCanvas() {
        const container = document.getElementById("chart-container");
        if (!container) return;

        heatmapCanvas = document.getElementById("heatmapCanvas");

        resizeHeatmapCanvas();
        window.addEventListener("resize", resizeHeatmapCanvas);
    }

    // ‚≠ê Redimensionar canvas al tama√±o real del gr√°fico
    function resizeHeatmapCanvas() {
        const container = document.getElementById("chart-container");
        if (!container || !heatmapCanvas) return;

        heatmapCanvas.width = container.offsetWidth;
        heatmapCanvas.height = container.offsetHeight;
        heatmapCanvas.style.width = container.offsetWidth + 'px';
        heatmapCanvas.style.height = container.offsetHeight + 'px';
    }

    
    // Manejo de gr√°fico
    function initializeChart() {
      try {
        const chartContainer = document.getElementById("chart-container");
        if (!chartContainer) return;

        const loadingMsg = chartContainer.querySelector('.loading-message');
        if (loadingMsg) {
          loadingMsg.style.display = 'block';
          loadingMsg.textContent = "Inicializando gr√°fico...";
        }

        if (chart) {
          chart.remove();
          chart = null;
          candlestickSeries = null;
          emaSeries = null;
        }

        chart = LightweightCharts.createChart(chartContainer, {
          width: chartContainer.offsetWidth,
          height: 400,
          layout: { backgroundColor: '#0f0f0f', textColor: '#d1d4dc' },
          grid: { vertLines: { color: '#333' }, horzLines: { color: '#333' }},
          handleScroll: {
            mouseWheel: true,
            pressedMouseMove: true,
            horzTouchDrag: true,
            vertTouchDrag: true,
          },
          handleScale: {
            axisPressedMouseMove: true,
            mouseWheel: true,
            pinch: true,
          },
        });

        setupHeatmapCanvas();

        candlestickSeries = chart.addCandlestickSeries({
          upColor: '#00ff00',
          downColor: '#ff0000',
        });

        emaSeries = chart.addLineSeries({
          color: '#ff9800',
          lineWidth: 2,
          extendToLastBar: true,
          extendToRightEdge: true,
          priceLineVisible: false
        });

      } catch (err) {
        showError(`Error al inicializar el gr√°fico: ${err.message}`);
      }
    }
        // ===============================
    // üî• SISTEMA LIMPIO DE ZONAS SMC
    // ===============================

    // M√°ximo 5 zonas por temporalidad
    const MAX_ZONAS = 5;

    // Umbrales de liquidez
    const ZONA_UMBRAL = {
        oro: 200_000_000,     // >= 200M
        fuerte: 100_000_000,  // >= 100M
        suave: 30_000_000     // >= 30M
    };

    // Colores SMC
    const ZONA_COLOR = {
        oro: "#FFD700",      // Dorado
        fuerte: "#FF4500",   // Rojo fuerte
        suave: "#00FF7F"     // Verde suave
    };

    // Lista global de zonas activas
    let zonasSMC = [];


    // ===============================
    // üìå CLASIFICAR NIVEL DE LIQUIDEZ
    // ===============================
    function clasificarZona(usdt) {
        if (usdt >= ZONA_UMBRAL.oro) return "oro";
        if (usdt >= ZONA_UMBRAL.fuerte) return "fuerte";
        if (usdt >= ZONA_UMBRAL.suave) return "suave";
        return null;
    }
    // =======================================
    // üìå AGREGAR UNA ZONA SI ES IMPORTANTE
    // =======================================
    function agregarZona(price, usdt) {
        const tipo = clasificarZona(usdt);
        if (!tipo) return; // No cumple umbral m√≠nimo

        zonasSMC.push({
            price,
            usdt,
            tipo,
            timestamp: Date.now()
        });

        zonasSMC.sort((a, b) => b.usdt - a.usdt); // ordenar por fuerza
        zonasSMC = zonasSMC.slice(0, MAX_ZONAS); // solo 5 mejores
    }
    // =======================================
    // üìå DIBUJAR ZONAS SOBRE EL GR√ÅFICO
    // =======================================
    function dibujarZonasSMC() {
        if (!chart || !candlestickSeries) return;

        const ctx = heatmapCanvas.getContext("2d", { willReadFrequently: true });
        ctx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);

        zonasSMC.forEach(z => {
            const y = candlestickSeries.priceToCoordinate(z.price);
            if (y == null) return;

            ctx.fillStyle = ZONA_COLOR[z.tipo];
            ctx.globalAlpha = 0.35;

            ctx.fillRect(
                0,
                y - 4,
                heatmapCanvas.width,
                8
            );

            ctx.globalAlpha = 1;
        });
    }
    // ===============================
    // üìå BORRAR ZONA CUANDO PRECIO TOCA
    // ===============================
    function eliminarZonasTocadas(currentPrice) {
        zonasSMC = zonasSMC.filter(z => {
            if (z.tipo === "oro") {
                // Las doradas NO se borran hasta romperse claramente
                return Math.abs(z.price - currentPrice) > 1;
            }

            // Las dem√°s se borran si el precio toca
            return Math.abs(z.price - currentPrice) > 0.5;
        });
    }
    // ===============================
    // üîÑ ACTUALIZAR ZONAS EN VIVO
    // LLAMA ESTO EN onmessage()
    // ===============================
    function procesarLiquidez(price, quantity, isAsk) {
        const usdt = price * quantity;
        agregarZona(price, usdt);  // agrega si es importante
        dibujarZonasSMC();         // dibuja
    }
    function priceToY(price) {
        if (!candlestickSeries) return null;
        const y = candlestickSeries.priceToCoordinate(price);
        return y === undefined ? null : y;
    }
    // Autoajustar gr√°fico
    function autoScaleChart() {
      if (chart) {
        chart.timeScale().fitContent();
      }
    }

    // Cargar datos hist√≥ricos de velas
    async function loadHistoricalKlines() {
      try {
        const loadingMsg = document.querySelector('.loading-message');
        if (loadingMsg) loadingMsg.textContent = "Cargando datos hist√≥ricos...";
        
        // üî• CAMBIA A 1000 VELAS HIST√ìRICAS
        const candleLimit = 1000;  // Cambiado 500 ‚Üí 1000
        
        const response = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${currentInterval}&limit=${candleLimit}`);
        if (!response.ok) throw new Error(`Error HTTP: ${response.status}`);
        
        const data = await response.json();
        candlesData = data.map(kline => ({
          time: Math.floor(kline[0] / 1000),
          open: parseFloat(kline[1]),
          high: parseFloat(kline[2]),
          low: parseFloat(kline[3]),
          close: parseFloat(kline[4]),
        }));
        
        // üî• MANTENER SOLO 1000 VELAS
        if (candlesData.length > 1000) candlesData = candlesData.slice(-1000);  // Cambiado -500 ‚Üí -1000
        
        if (candlestickSeries) {
          candlestickSeries.setData(candlesData);
          
          // üî• CALCULA EMA CON 1000 VELAS
          const ema100 = calculateEMA(candlesData, 100);
          if (emaSeries) emaSeries.setData(ema100);
          
          //chart.timeScale().fitContent();
          
          const loadingMsg = document.querySelector('.loading-message');
          if (loadingMsg) loadingMsg.style.display = 'none';
        }
      } catch (err) {
        showError(`Error al cargar el historial de velas: ${err.message}`);
        // ... resto del c√≥digo ...
      }
    }

    function calculateEMA(data, period) {
      if (!data || data.length === 0) return [];
      
      const k = 2 / (period + 1);
      const emaData = [];
      
      // Para EMA 100, necesitamos al menos 100 puntos para buen c√°lculo
      if (data.length < period) {
        // Si hay pocos datos, calcular EMA progresiva
        let ema = data[0].close;
        emaData.push({ time: data[0].time, value: ema });
        
        for (let i = 1; i < data.length; i++) {
          ema = (data[i].close * k) + (ema * (1 - k));
          emaData.push({ time: data[i].time, value: ema });
        }
      } else {
        // Si hay suficientes datos, calcular EMA est√°ndar
        // Calcular SMA inicial para los primeros 'period' datos
        let sma = 0;
        for (let i = 0; i < period; i++) {
          sma += data[i].close;
        }
        let ema = sma / period;
        
        // Primer punto EMA (en la posici√≥n 'period-1')
        emaData.push({ 
          time: data[period - 1].time, 
          value: ema 
        });
        
        // Calcular EMA para el resto
        for (let i = period; i < data.length; i++) {
          ema = (data[i].close * k) + (ema * (1 - k));
          emaData.push({ 
            time: data[i].time, 
            value: ema 
          });
        }
      }
      
      return emaData;
    }

    // Manejo de l√≠neas de precio seleccionadas
    function drawSelectedPriceLine(price, isAsk) {
      if (!chart || !candlestickSeries) return;
      
      const now = Math.floor(Date.now() / 1000);
      const lineSeries = chart.addLineSeries({
        color: isAsk ? '#ff0000' : '#00ff00',
        lineWidth: 2,
        priceLineVisible: false,
        lastValueVisible: false,
      });
      
      lineSeries.setData([
        { time: now - 86400, value: price },
        { time: now, value: price },
      ]);
      
      lineSeries.createPriceLine({
        price: price,
        color: isAsk ? '#ff0000' : '#00ff00',
        lineWidth: 1,
        lineStyle: LightweightCharts.LineStyle.Dashed,
        title: `${isAsk ? 'Ask' : 'Bid'}: ${formatPrice(price)}`,
      });
      
      selectedPrices.set(price, { series: lineSeries, isAsk: isAsk });
      saveSelectedPrices();
    }
    
    function removeSelectedPriceLine(price) {
      if (!chart) return;
      
      const priceData = selectedPrices.get(price);
      if (priceData && priceData.series) {
        try {
          chart.removeSeries(priceData.series);
        } catch (err) {
          console.warn(`Error al remover serie: ${err.message}`);
        }
      }
      
      selectedPrices.delete(price);
      saveSelectedPrices();
    }
    
    function redrawSelectedLines() {
      if (!chart) return;
      
      const pricesToRedraw = new Map(selectedPrices);
      selectedPrices.clear();
      
      pricesToRedraw.forEach((data, price) => {
        if (data.series) {
          try {
            chart.removeSeries(data.series);
          } catch (err) {
            console.warn(`Error al remover serie: ${err.message}`);
          }
        }
        
        if (futuresAsksData.some(order => order.price === price) || 
            futuresBidsData.some(order => order.price === price)) {
          const isAsk = futuresAsksData.some(order => order.price === price);
          drawSelectedPriceLine(price, isAsk);
        }
      });
    }
    
    function togglePriceSelection(price, isAsk, checkbox) {
        startInteraction();

        if (checkbox.checked) {
            if (!selectedPrices.has(price)) {
                drawSelectedPriceLine(price, isAsk);
                
                // üî• NUEVO: Registrar zona para backtesting
                const zoneData = analyzeZoneForBacktest(price, isAsk);
                registerZoneForBacktesting(zoneData);
                
                if (isAsk) {
                    asksPriceMap.set(price, true);
                } else {
                    bidsPriceMap.set(price, true);
                }
            }
        } else {
            if (selectedPrices.has(price)) {
                removeSelectedPriceLine(price);
                asksPriceMap.delete(price);
                bidsPriceMap.delete(price);
                
                // üî• NUEVO: Eliminar del backtesting
                removeZoneFromBacktesting(price);
            }
        }

        updateTables();
        setTimeout(endInteraction, 300);
    }

        // =====================================================
    // üîç FUNCIONES B√ÅSICAS DE BACKTESTING
    // =====================================================

    function analyzeZoneForBacktest(price, isAsk) {
        const now = Date.now();
        const totalOrders = asksProcessed + bidsProcessed;
        
        return {
            id: `zone_${price}_${now}`,
            price: price,
            type: isAsk ? 'resistance' : 'support',
            timestamp: now,
            initialData: {
                markPrice: markPriceFutures,
                distanceFromMark: markPriceFutures ? 
                    Math.abs((price - markPriceFutures) / markPriceFutures * 100).toFixed(3) : 0,
                ordersProcessed: totalOrders,
                liquidity: getLiquidityAtPrice(price, isAsk),
                bidAskRatio: calculateBidAskRatioAtPrice(price)
            },
            hits: [],
            rebounds: [],
            statistics: {
                totalHits: 0,
                successfulRebounds: 0,
                avgOrdersBeforeHit: 0,
                successRate: 0,
                confidenceScore: 0
            }
        };
    }

    function getLiquidityAtPrice(price, isAsk) {
        const data = isAsk ? futuresAsksData : futuresBidsData;
        const order = data.find(o => Math.abs(o.price - price) < 0.0001);
        return order ? order.usdt : 0;
    }

    function calculateBidAskRatioAtPrice(price) {
        const bidOrder = futuresBidsData.find(o => Math.abs(o.price - price) < 0.0001);
        const askOrder = futuresAsksData.find(o => Math.abs(o.price - price) < 0.0001);
        
        if (!bidOrder || !askOrder) return 1;
        return bidOrder.usdt / askOrder.usdt;
    }

    function registerZoneForBacktesting(zoneData) {
        const priceKey = zoneData.price.toFixed(2);
        
        if (!zoneBacktestData.zones[priceKey]) {
            zoneBacktestData.zones[priceKey] = {
                history: [],
                current: zoneData,
                dailyStats: {}
            };
            currentSessionStats.totalZones++;
        }
        
        zoneBacktestData.zones[priceKey].current = zoneData;
        zoneBacktestData.zones[priceKey].history.push({
            timestamp: Date.now(),
            action: 'registered',
            data: zoneData.initialData
        });
        
        // Limitar historial
        if (zoneBacktestData.zones[priceKey].history.length > 50) {
            zoneBacktestData.zones[priceKey].history.shift();
        }
        
        localStorage.setItem(`zoneBacktest_${symbol}`, JSON.stringify(zoneBacktestData));
        
        // Dibujar zona en gr√°fico
        drawZoneWithBacktestInfo(zoneData);
        
        // Mostrar confirmaci√≥n
        showAlert(`üìä Zona ${priceKey} registrada para an√°lisis`, 'volume');
    }

    function removeZoneFromBacktesting(price) {
        const priceKey = price.toFixed(2);
        if (zoneBacktestData.zones[priceKey]) {
            delete zoneBacktestData.zones[priceKey];
            localStorage.setItem(`zoneBacktest_${symbol}`, JSON.stringify(zoneBacktestData));
            currentSessionStats.totalZones = Object.keys(zoneBacktestData.zones).length;
        }
    }

    function drawZoneWithBacktestInfo(zoneData) {
        if (!candlestickSeries) return;
        
        const markers = candlestickSeries.markers() || [];
        const price = zoneData.price;
        
        const marker = {
            time: Math.floor(Date.now() / 1000),
            position: zoneData.type === 'support' ? 'belowBar' : 'aboveBar',
            color: zoneData.type === 'support' ? '#00FF00' : '#FF0000',
            shape: zoneData.type === 'support' ? 'arrowUp' : 'arrowDown',
            text: `${zoneData.type === 'support' ? 'S' : 'R'}@${formatPrice(price)}`,
            size: 1
        };
        
        markers.push(marker);
        
        // Mantener m√°ximo 30 marcadores
        if (markers.length > 30) {
            markers.splice(0, markers.length - 30);
        }
        
        candlestickSeries.setMarkers(markers);
    }

    // =====================================================
    // üîÑ MONITOREO SIMPLE DE ZONAS
    // =====================================================

    function monitorZoneHits() {
        if (!markPriceFutures || Object.keys(zoneBacktestData.zones).length === 0) return;
        
        const currentPrice = markPriceFutures;
        const now = Date.now();
        const totalOrders = asksProcessed + bidsProcessed;
        
        Object.keys(zoneBacktestData.zones).forEach(priceKey => {
            const zone = zoneBacktestData.zones[priceKey];
            const zonePrice = parseFloat(priceKey);
            
            // Calcular distancia al precio actual
            const distance = Math.abs(currentPrice - zonePrice) / zonePrice * 100;
            
            // Verificar hit (0.2% de tolerancia)
            if (distance < 0.2) {
                registerZoneHit(zonePrice, now, totalOrders);
            }
        });
    }

    function registerZoneHit(price, timestamp, ordersAtHit) {
        const priceKey = price.toFixed(2);
        
        if (!zoneBacktestData.zones[priceKey]) return;
        
        const zone = zoneBacktestData.zones[priceKey];
        
        // Incrementar contadores
        zone.current.statistics.totalHits++;
        currentSessionStats.zonesHit++;
        
        // Registrar datos del hit
        const hitData = {
            timestamp: timestamp,
            ordersAtHit: ordersAtHit,
            totalOrdersSinceRegistration: ordersAtHit - zone.current.initialData.ordersProcessed,
            markPrice: markPriceFutures
        };
        
        zone.current.hits.push(hitData);
        
        // Mantener solo √∫ltimos 20 hits
        if (zone.current.hits.length > 20) {
            zone.current.hits.shift();
        }
        
        // Calcular estad√≠sticas
        updateZoneStatistics(priceKey);
        
        // Mostrar notificaci√≥n
        if (zone.current.statistics.totalHits <= 3) {
            showAlert(`üéØ ${zone.current.type === 'support' ? 'Soporte' : 'Resistencia'} ${priceKey} tocada!`, 'volume');
        }
    }

    function updateZoneStatistics(priceKey) {
        const zone = zoneBacktestData.zones[priceKey];
        if (!zone || zone.current.hits.length === 0) return;
        
        const stats = zone.current.statistics;
        const hits = zone.current.hits;
        
        // Calcular √≥rdenes promedio antes del hit
        if (hits.length > 0) {
            const totalOrders = hits.reduce((sum, hit) => sum + hit.totalOrdersSinceRegistration, 0);
            stats.avgOrdersBeforeHit = Math.round(totalOrders / hits.length);
        }
        
        // Calcular puntaje de confianza simple
        stats.confidenceScore = Math.min(stats.totalHits * 10, 100);
        
        localStorage.setItem(`zoneBacktest_${symbol}`, JSON.stringify(zoneBacktestData));
    }

        // =====================================================
    // üì± PANEL DE BACKTESTING EN TIEMPO REAL
    // =====================================================

    function updateBacktestDisplay() {
        // Crear o actualizar panel
        let backtestPanel = document.getElementById('backtest-panel');
        
        if (!backtestPanel) {
            backtestPanel = document.createElement('div');
            backtestPanel.id = 'backtest-panel';
            backtestPanel.style.cssText = `
                background-color: #151515;
                border: 1px solid #333;
                padding: 12px;
                margin: 10px 0;
                border-radius: 3px;
                font-size: 11px;
            `;
            
            // Insertar despu√©s del contenedor de estad√≠sticas
            const statsContainer = document.querySelector('.market-stats-container');
            if (statsContainer && statsContainer.parentNode) {
                statsContainer.parentNode.insertBefore(backtestPanel, statsContainer.nextSibling);
            }
        }
        
        // Calcular estad√≠sticas
        const totalZones = Object.keys(zoneBacktestData.zones).length;
        const zonesWithHits = Object.values(zoneBacktestData.zones)
            .filter(z => z.current.statistics.totalHits > 0).length;
        
        // Calcular promedio de √≥rdenes antes del hit
        const zonesWithData = Object.values(zoneBacktestData.zones)
            .filter(z => z.current.statistics.avgOrdersBeforeHit > 0);
        
        const avgOrdersBeforeHit = zonesWithData.length > 0
            ? Math.round(zonesWithData.reduce((sum, z) => sum + z.current.statistics.avgOrdersBeforeHit, 0) / zonesWithData.length)
            : 0;
        
        // Calcular √©xito total
        const totalHits = currentSessionStats.zonesHit;
        const totalRebounds = currentSessionStats.successfulRebounds + currentSessionStats.failedRebounds;
        const successRate = totalRebounds > 0 
            ? Math.round((currentSessionStats.successfulRebounds / totalRebounds) * 100)
            : 0;
        
        // Obtener zonas m√°s activas (con m√°s hits)
        const activeZones = Object.entries(zoneBacktestData.zones)
            .map(([price, data]) => ({
                price: parseFloat(price),
                stats: data.current.statistics,
                type: data.current.type,
                hits: data.current.statistics.totalHits
            }))
            .filter(z => z.hits > 0)
            .sort((a, b) => b.hits - a.hits)
            .slice(0, 3);
        
        backtestPanel.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="color: #9c27b0; margin: 0; font-size: 12px;">üß† BACKTESTING DE ZONAS</h3>
                <div style="display: flex; gap: 8px; font-size: 10px;">
                    <span style="color: ${totalHits > 0 ? '#00ff88' : '#888'}">üéØ ${totalHits}</span>
                    <span style="color: ${currentSessionStats.successfulRebounds > 0 ? '#00ff88' : '#888'}">‚úÖ ${currentSessionStats.successfulRebounds}</span>
                    <span style="color: ${currentSessionStats.failedRebounds > 0 ? '#ff5555' : '#888'}">‚ùå ${currentSessionStats.failedRebounds}</span>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px;">
                <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 6px; border-radius: 3px;">
                    <div style="font-size: 9px; color: #888;">Zonas</div>
                    <div style="font-size: 14px; font-weight: bold;">${zonesWithHits}/${totalZones}</div>
                </div>
                
                <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 6px; border-radius: 3px;">
                    <div style="font-size: 9px; color: #888;">√ìrdenes/hit</div>
                    <div style="font-size: 14px; font-weight: bold;">${avgOrdersBeforeHit > 0 ? avgOrdersBeforeHit.toLocaleString() : '--'}</div>
                </div>
                
                <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 6px; border-radius: 3px;">
                    <div style="font-size: 9px; color: #888;">√âxito</div>
                    <div style="font-size: 14px; font-weight: bold; color: ${successRate >= 70 ? '#00ff88' : successRate >= 50 ? '#ffaa00' : '#ff5555'}">
                        ${successRate}%
                    </div>
                </div>
            </div>
            
            ${activeZones.length > 0 ? `
            <div style="margin-bottom: 10px;">
                <div style="font-size: 10px; color: #888; margin-bottom: 5px;">üèÜ Zonas M√°s Activas:</div>
                <div style="font-size: 9px;">
                    ${activeZones.map(zone => `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid #2a2a2a;">
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <span style="color: ${zone.type === 'support' ? '#00ff88' : '#ff5555'}">${zone.type === 'support' ? 'üü¢' : 'üî¥'}</span>
                                <span>${formatPrice(zone.price)}</span>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 10px; color: #888;">${zone.hits} hits</div>
                                <div style="font-size: 9px; color: ${zone.stats.confidenceScore >= 80 ? '#00ff88' : zone.stats.confidenceScore >= 60 ? '#ffaa00' : '#ff5555'}">
                                    C:${zone.stats.confidenceScore}%
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
            ` : totalZones > 0 ? `
            <div style="text-align: center; padding: 10px; color: #888; font-size: 10px;">
                ‚è≥ Esperando que el precio toque las zonas seleccionadas...
            </div>
            ` : `
            <div style="text-align: center; padding: 10px; color: #888; font-size: 10px;">
                üìå Selecciona zonas en las tablas para comenzar el an√°lisis
            </div>
            `}
            
            <div style="display: flex; justify-content: space-between; font-size: 9px; color: #888; border-top: 1px solid #333; padding-top: 8px;">
                <div>
                    <div>üìä Total √≥rdenes: ${(asksProcessed + bidsProcessed).toLocaleString()}</div>
                    <div>‚è±Ô∏è Sesi√≥n: ${formatSessionDuration(currentSessionStats.startTime)}</div>
                </div>
                <div style="text-align: right;">
                    <div>${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
                    <div>${symbol}</div>
                </div>
            </div>
        `;
    }

    function formatSessionDuration(startTime) {
        const seconds = Math.floor((Date.now() - startTime) / 1000);
        if (seconds < 60) return `${seconds}s`;
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
        return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
    }

        
    function saveSelectedPrices() {
      const prices = Array.from(selectedPrices.keys());
      localStorage.setItem(`selectedPrices_${symbol}`, JSON.stringify(prices));
    }
    
    // Cargar pares de criptomonedas
    async function loadCryptoPairs() {
      try {
        const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
        if (!response.ok) throw new Error('Error al obtener pares de futuros');
        
        const data = await response.json();
        const datalist = document.getElementById('symbol-list');
        const validPairs = data.symbols
          .filter(s => s.status === 'TRADING' && s.quoteAsset === 'USDT')
          .map(s => s.symbol);
        
        datalist.innerHTML = '';
        validPairs.forEach(pair => {
          const option = document.createElement('option');
          option.value = pair;
          datalist.appendChild(option);
        });
      } catch (err) {
        console.error('Error al cargar pares:', err);
        showError(`Error al cargar pares: ${err.message}`);
      }
    }
    
    // Formateadores
    function formatPrice(price) {
      const decimals = getDecimals(symbol);
      return price.toFixed(decimals).replace(/(\.\d+?)0+$/, "$1");
    }
    
    function getDecimals(symbol) {
      const decimalsMap = {
        "BTCUSDT": 2,
        "ETHUSDT": 2,
        "BNBUSDT": 2,
        "SOLUSDT": 4,
        "XRPUSDT": 4,
        "ADAUSDT": 5,
        "DOGEUSDT": 5,
        "DOTUSDT": 3,
        "MATICUSDT": 4,
        "LTCUSDT": 2,
        "AVAXUSDT": 3,
        "LINKUSDT": 3,
        "ATOMUSDT": 3,
        "UNIUSDT": 3,
        "FILUSDT": 3,
        "XLMUSDT": 5,
        "ETCUSDT": 3,
        "XTZUSDT": 3,
        "SUSHIUSDT": 3,
        "AAVEUSDT": 2,
        "GRTUSDT": 5,
        "ALGOUSDT": 4,
        "KSMUSDT": 2,
        "COMPUSDT": 2,
        "YFIUSDT": 2,
        "SNXUSDT": 3,
        "BALUSDT": 3,
        "CRVUSDT": 4,
        "SANDUSDT": 5,
        "MANAUSDT": 5,
        "AXSUSDT": 3,
        "GALAUSDT": 6,
        "APEUSDT": 4,
        "PEOPLEUSDT": 6,
        "ENSUSDT": 3,
        "ANTUSDT": 3,
        "GMTUSDT": 4,
        "APEUSDT": 4,
        "GALUSDT": 5,
        "OPUSDT": 4,
        "INJUSDT": 3,
        "STGUSDT": 4,
        "SPELLUSDT": 6,
        "1000SHIBUSDT": 6,
        "1000PEPEUSDT": 8,
        "1000FLOKIUSDT": 7,
        "1000LUNCUSDT": 6,
        "1000XECUSDT": 6
      };
      
      return decimalsMap[symbol] || 4;
    }
    
    function formatQuantity(quantity) {
      if (quantity >= 1000000) return (quantity / 1000000).toFixed(2) + "M";
      if (quantity >= 1000) return (quantity / 1000).toFixed(2) + "K";
      return quantity.toFixed(4);
    }
    
    function formatUsdt(value) {
      if (value >= 1000000000) return (value / 1000000000).toFixed(2) + "B";
      if (value >= 1000000) return (value / 1000000).toFixed(2) + "M";
      if (value >= 1000) return (value / 1000).toFixed(2) + "K";
      return value.toFixed(2);
    }
    
    function formatAge(milliseconds) {
      if (milliseconds < 0) return "0s";
      
      const totalSeconds = Math.floor(milliseconds / 1000);
      
      if (totalSeconds < 60) return `${totalSeconds}s`;
      
      if (totalSeconds < 3600) return `${Math.floor(totalSeconds / 60)}m`;
      
      if (totalSeconds < 86400) return `${Math.floor(totalSeconds / 3600)}h`;
      
      return `${Math.floor(totalSeconds / 86400)}d`;
    }
    
    function updateTimestamp() {
        const now = new Date();
        
        // D√≠a de la semana (3 letras)
        const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const dayName = days[now.getDay()];
        
        // Fecha (mes/d√≠a/a√±o)
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const year = now.getFullYear();
        
        // Hora en formato 12h
        let hours = now.getHours();
        const ampm = hours >= 12 ? 'PM' : 'AM';
        hours = hours % 12;
        hours = hours ? hours : 12;
        
        // Formatear hora, minutos, segundos
        const hourStr = String(hours).padStart(2, '0');
        const minuteStr = String(now.getMinutes()).padStart(2, '0');
        const secondStr = String(now.getSeconds()).padStart(2, '0');
        
        // Resultado: Wed 12/10/2025, 09:33:35 AM UTC-5
        const timeString = `${dayName} ${month}/${day}/${year}, ${hourStr}:${minuteStr}:${secondStr} ${ampm} UTC-5`;
        
        // Actualizar en pantalla
        document.getElementById('compact-timestamp').textContent = timeString;
        
        // ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è VERSI√ìN 1: SIN CAMBIO DE COLOR (m√°s simple) ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è
        // (eliminado el c√≥digo que intentaba acceder a "symbol-title" que ya no existe)
        
        // ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è VERSI√ìN 2: CON CAMBIO DE COLOR PARA EL NUEVO PRECIO ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è
        // Actualizar color del precio si est√° desactualizado (para el NUEVO display)
        if (lastPriceUpdate) {
            const secondsSinceUpdate = (Date.now() - lastPriceUpdate) / 1000;
            const priceValue = document.getElementById("price-value");
            
            if (priceValue) {
                if (secondsSinceUpdate > 5) {
                    priceValue.style.color = "#ff5555"; // Rojo si desactualizado (>5 seg)
                } else {
                    priceValue.style.color = "#ffffff"; // Blanco si actualizado
                }
            }
        }
    }

    
    // Manejo de errores
    function showError(message) {
      errorMessageElement.textContent = message;
      console.error(message);
    }
    
    function clearError() {
      errorMessageElement.textContent = "";
    }
    
    function updateWsStatus(message) {
      const statusElement = document.getElementById("ws-status");
      if (statusElement) {
        statusElement.textContent = message;
        
        const spinner = statusElement.querySelector('.spinner');
        if (spinner) {
          spinner.style.display = message.includes('Conectado') ? 'none' : 'inline-block';
        }
      }
    }

    function updatePriceDisplay() {
        // desactivada: el header solo lo actualiza el TICKER (24h)
    }


    // ============================================
    // üìà ACTUALIZAR DISPLAY COMPLETO DEL S√çMBOLO
    // ============================================


    /*
    function updateRealTimePrice(newPrice, changePercent = 0) {
        ...
    }
    */

  
    
    // Configurar eventos
    function setupEventListeners() {
      const asksBody = document.getElementById("asks-body");
      const bidsBody = document.getElementById("bids-body");
      
      if (asksBody) {
        asksBody.addEventListener('click', handleTableClick);
        asksBody.addEventListener('mousedown', handleTableMouseDown);
      }
      
      if (bidsBody) {
        bidsBody.addEventListener('click', handleTableClick);
        bidsBody.addEventListener('mousedown', handleTableMouseDown);
      }
      
      document.getElementById('symbol-search').addEventListener('change', (e) => {
        const selectedSymbol = e.target.value.toUpperCase();
        if (selectedSymbol) {
          window.location.href = `?symbol=${selectedSymbol}`;
        }
      });
      
      document.getElementById('interval-select').addEventListener('change', changeChartInterval);
      
      window.addEventListener('resize', () => {
        if (chart) {
          chart.resize(document.getElementById("chart-container").offsetWidth, 400);
          redrawSelectedLines();
        }
      });
    }
    
    function handleTableMouseDown(event) {
      const cell = event.target.closest('.price-cell');
      if (!cell) return;
      
      const span = cell.querySelector('span');
      if (!span) return;
      
      const selection = window.getSelection();
      if (!selection.toString()) {
        const range = document.createRange();
        range.selectNodeContents(span);
        selection.removeAllRanges();
        selection.addRange(range);
      }
      
      event.preventDefault();
    }
    
    function handleTableClick(event) {
      const cell = event.target.closest('.price-cell');
      if (!cell) return;
      
      copyPriceCell({target: cell});
    }
    
    function copyPriceCell(event) {
      const cell = event.target.closest('.price-cell');
      if (!cell) return;
      
      const text = cell.textContent.trim();
      if (!text) return;
      
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(() => {
          cell.classList.add("copied");
          setTimeout(() => cell.classList.remove("copied"), 500);
          isInteracting = false;
        }).catch(err => {
          console.error("Error al copiar:", err);
          copyWithFallback(text, cell);
        });
      } else {
        copyWithFallback(text, cell);
      }
      
      event.preventDefault();
    }
    
    function copyWithFallback(text, cell) {
      const textArea = document.createElement("textarea");
      textArea.value = text;
      textArea.style.position = "fixed";
      textArea.style.opacity = "0";
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      
      try {
        document.execCommand('copy');
        cell.classList.add("copied");
        setTimeout(() => cell.classList.remove("copied"), 500);
        isInteracting = false;
      } catch (err) {
        console.error("Error al copiar con fallback:", err);
      } finally {
        document.body.removeChild(textArea);
      }
    }

    // ===============================
    // ‚≠ê FULLSCREEN TIPO TRADINGVIEW (VERSI√ìN MEJORADA)
    // ===============================
    function setupFullscreenButton() {
        const chartSection = document.getElementById("chart-container");
        const fullscreenBtn = document.getElementById("tv-fullscreen-btn");
        const body = document.body;
        const header = document.querySelector('.header-controls');

        if (!chartSection || !fullscreenBtn) return;

        fullscreenBtn.addEventListener("click", () => {
            const isFull = chartSection.classList.toggle("fullscreen-mode");
            
            // A√±adir/remover clase al body para ocultar elementos
            body.classList.toggle("fullscreen-active", isFull);

            // Cambiar icono
            fullscreenBtn.innerHTML = isFull
                ? `<svg viewBox="0 0 24 24"><path d="M5 5h5v2H7v3H5V5zm14 0v5h-2V7h-3V5h5zm-5 14h3v-2h2v5h-5v-3zm-4 3H5v-5h2v3h3v2z"/></svg>`
                : `<svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm0-4h2V7h3V5H7v5zm10 7h-3v2h5v-5h-2v3zm-3-7h2V7h3V5h-5v5z"/></svg>`;

            // Redimensionar gr√°fico
            if (chart) {
                // Peque√±o retraso para asegurar que el contenedor tenga sus nuevas dimensiones
                setTimeout(() => {
                    if (isFull) {
                        chart.resize(chartSection.offsetWidth, chartSection.offsetHeight);
                        chart.timeScale().fitContent(); // Ajustar al contenido en fullscreen
                    } else {
                        chart.resize(chartSection.offsetWidth, 400);
                    }
                }, 50);
            }

            // Ajustar canvas del heatmap
            if (heatmapCanvas) {
                resizeHeatmapCanvas();
            }

            // Ajustar posici√≥n del bot√≥n
            if (isFull) {
                fullscreenBtn.style.top = '90px'; // Debajo del header
            } else {
                fullscreenBtn.style.top = '5px'; // Posici√≥n original
            }
        });

        // Manejar la tecla ESC para salir de fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && chartSection.classList.contains('fullscreen-mode')) {
                chartSection.classList.remove('fullscreen-mode');
                body.classList.remove('fullscreen-active');
                
                // Restaurar icono
                fullscreenBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm0-4h2V7h3V5H7v5zm10 7h-3v2h5v-5h-2v3zm-3-7h2V7h3V5h-5v5z"/></svg>`;
                
                // Restaurar posici√≥n del bot√≥n
                fullscreenBtn.style.top = '5px';
                
                // Redimensionar gr√°fico
                if (chart) {
                    setTimeout(() => {
                        chart.resize(chartSection.offsetWidth, 400);
                    }, 50);
                }
            }
        });

        // Ajustar en resize
        window.addEventListener('resize', () => {
            if (chartSection.classList.contains('fullscreen-mode')) {
                if (chart) {
                    setTimeout(() => {
                        chart.resize(chartSection.offsetWidth, chartSection.offsetHeight);
                    }, 50);
                }
                if (heatmapCanvas) {
                    resizeHeatmapCanvas();
                }
            }
        });
    }

    // ===============================
    // Inicializaci√≥n
    // ===============================
    function init() {
        // Inicializar el display de precio con valores por defecto
                      
        loadSelectedPrices();
        setupEventListeners();
        initializeWebSockets();
        setInterval(updateTimestamp, 1000);
        loadCryptoPairs();
        initAlerts();
        setupFullscreenButton();

        // ‚úÖ A√ëADE ESTA L√çNEA:
        addReconnectButton();

        // üî• AGREGAR ESTAS 4 L√çNEAS PARA BACKTESTING:
        // Inicializar backtesting
        currentSessionStats.ordersAtStart = asksProcessed + bidsProcessed;
        setInterval(monitorZoneHits, 3000); // Monitorear cada 3 segundos
        setInterval(updateBacktestDisplay, 5000); // Actualizar panel cada 5 segundos
        setTimeout(() => updateBacktestDisplay(), 2000); // Mostrar panel despu√©s de 2 segundos

        // Exponer funciones globales
        window.toggleClusters = toggleClusters;
        window.startInteraction = startInteraction;
        window.endInteraction = endInteraction;
        window.togglePriceSelection = togglePriceSelection;
        window.autoScaleChart = autoScaleChart;
        window.updateThresholds = updateThresholds;
        window.toggleSoundAlerts = toggleSoundAlerts;
        window.saveKeyLevels = saveKeyLevels;
        window.copyPriceCell = copyPriceCell;
        
        // ‚úÖ A√ëADE ESTAS 2 L√çNEAS:
       // window.reconnectAllWebSockets = reconnectAllWebSockets;
        window.wsManager = wsManager;

        // üî• AGREGAR ESTA L√çNEA PARA BACKTESTING:
        window.updateBacktestDisplay = updateBacktestDisplay;
    }

    // üöÄ Iniciar la app
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
