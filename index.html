<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Libro de √ìrdenes Mejorado - Futuros Binance</title>
  <style>
    :root {
      --bg-color: #1a1a1a;
      --panel-color: #2f2f2f;
      --border-color: #444;
      --text-color: #ffffff;
      --text-secondary: #cccccc;
      --ask-color: #ff5555;
      --bid-color: #55ff55;
      --highlight-ask: rgba(249, 12, 12, 0.5);
      --highlight-bid: rgba(0, 255, 0, 0.5);
      --color-purple: #9c27b0;
    }
    
    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 20px;
      position: relative;
    }
    
    .header-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      padding: 10px;
      background-color: var(--panel-color);
      border-radius: 5px;
      box-sizing: border-box;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .header-left {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 250px;
      flex-grow: 1;
    }
    
    .header-center {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0;
      flex-grow: 1;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }
    
    .header-info-line {
      margin: 0;
      line-height: 1.2;
      white-space: nowrap;
    }
    
    .search-container {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .symbol-title {
      margin-left: 20px;
      white-space: nowrap;
    }
    
    .interval-selector {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 5px;
      min-width: 120px;
    }
    
    .header-controls h1 {
      margin: 0;
      color: var(--bid-color);
      font-size: 20px;
    }
    
    .time-stats p {
      margin: 0;
      color: var(--text-secondary);
      font-size: 11px;
      line-height: 1.2;
    }
    
    .interval-selector select, 
    .interval-selector button,
    .search-container input,
    .liquidity-thresholds input {
      background-color: var(--panel-color);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      padding: 5px 8px;
      font-size: 12px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s ease;
      width: 80px;
    }
    
    .interval-selector select:focus,
    .search-container input:focus,
    .liquidity-thresholds input:focus {
      outline: none;
      border-color: var(--bid-color);
      box-shadow: 0 0 0 2px rgba(0, 255, 0, 0.1);
    }
    
    .interval-selector button:hover,
    .liquidity-btn:hover {
      background-color: var(--border-color);
    }
    
    .error-message {
      color: var(--ask-color);
      text-align: center;
      margin: 10px 0;
      font-size: 12px;
    }
    
    .loading-message {
      color: var(--bid-color);
      text-align: center;
      margin: 10px 0;
      font-size: 12px;
    }
    
    .chart-container {
      width: 100%;
      height: 500px;
      margin: 20px 0;
      border: 1px solid var(--border-color);
      background-color: var(--panel-color);
      border-radius: 5px;
      position: relative;
    }
    
    .container {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .panel {
      flex: 1;
      border: 1px solid var(--border-color);
      background-color: var(--panel-color);
      padding: 5px 10px 10px 10px;
      min-width: 300px;
      border-radius: 5px;
      position: relative;
    }
    
    .title-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      width: 100%;
      text-align: center;
      margin-top: -5px;
      margin-bottom: 10px;
    }
    
    h2 {
      margin: 0;
      color: var(--bid-color);
      font-size: 18px;
    }
    
    .asks-title {
      color: var(--ask-color);
    }
    
    .processed-count {
      font-size: 16px;
      font-weight: bold;
    }
    
    .asks-processed {
      color: var(--ask-color);
    }
    
    .bids-processed {
      color: var(--bid-color);
    }
    
    .indicator-circle {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    
    .indicator-circle-start {
      margin-right: 5px;
    }
    
    .indicator-circle-end {
      margin-left: 5px;
    }
    
    .circle-red {
      background-color: var(--ask-color) !important;
    }
    
    .circle-green {
      background-color: var(--bid-color) !important;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: var(--panel-color);
      border: 1px solid var(--border-color);
      margin-bottom: 10px;
      font-size: 12px;
      border-radius: 5px;
      overflow: hidden;
    }
    
    th, td {
      padding: 5px 6px;
      border: 1px solid var(--border-color);
      position: relative;
      cursor: pointer;
      line-height: 1.2;
      text-align: center;
    }
    
    th {
      background-color: #333;
      color: var(--bid-color);
      font-weight: 500;
      position: sticky;
      top: 0;
      font-size: 11px;
    }
    
    td {
      color: var(--text-secondary);
      user-select: none;
      font-size: 11px;
    }
    
    td span {
      display: inline-block;
      width: 100%;
      text-align: center;
      user-select: text;
    }
    
    td::selection, td span::selection {
      background: rgba(0, 255, 0, 0.3);
    }
    
    .ask-row { color: var(--text-secondary); }
    .bid-row { color: var(--text-secondary); }
    
    tr:hover { background-color: #3a3a3a; }
    
    .bold-row td {
      font-weight: bold;
    }
    
    .color-transparent {
      background-color: transparent;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    
    .color-purple {
      background-color: var(--color-purple);
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    
    .color-purple td {
      color: var(--text-color);
    }
    
    .highlight-red {
      background-color: var(--highlight-ask) !important;
      transition: background-color 1s ease-out;
    }
    
    .highlight-red td {
      color: var(--text-color) !important;
      font-weight: bold;
    }
    
    tr.highlight-green {
      background-color: var(--bid-color) !important;
      transition: background-color 1s ease-out;
    }
    
    tr.highlight-green td {
      color: #000000 !important;
      font-weight: bold;
    }
    
    .legend {
      display: flex;
      flex-direction: column;
      gap: 3px;
      margin-top: 8px;
    }
    
    .legend-row {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      border-radius: 3px;
      font-size: 9px;
      background-color: var(--panel-color);
      color: var(--text-secondary);
      margin-bottom: 3px;
      line-height: 1.1;
    }
    
    .legend .bid-updated-legend {
      background-color: var(--bid-color) !important;
      color: #000000 !important;
    }
    
    .copied {
      background-color: rgba(0, 255, 0, 0.3);
      transition: background-color 0.5s ease;
    }
    
    .price-cell:hover {
      background-color: rgba(0, 255, 0, 0.1);
      transition: none;
    }
    
    .highlight-total {
      background-color: #004d00;
      padding: 1px 3px;
      border-radius: 3px;
      font-size: 11px;
    }
    
    .selected-row {
      background-color: rgba(0, 255, 0, 0.3) !important;
    }
    
    .selected-column {
      width: 25px;
      text-align: center;
      position: relative;
    }
    
    .selected-column:hover {
      background-color: rgba(0, 255, 0, 0.1);
    }
    
    .selection-checkbox {
      cursor: pointer;
      width: 12px;
      height: 12px;
    }
    
    .selection-checkbox:checked {
      accent-color: var(--ask-color);
    }
    
    #bids-body .selection-checkbox:checked {
      accent-color: var(--bid-color);
    }
    
    .selection-checkbox:active {
      outline: 2px solid var(--bid-color);
    }
    
    .search-container label {
      margin-right: 5px;
      font-size: 12px;
      color: var(--text-secondary);
    }
    
    .search-container input {
      background-color: var(--panel-color);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      padding: 5px 8px;
      font-size: 12px;
      border-radius: 5px;
      width: 120px;
      transition: all 0.2s ease;
    }
    
    .search-container input:focus {
      outline: none;
      border-color: var(--bid-color);
    }
    
    .spinner {
      border: 2px solid rgba(0, 255, 0, 0.3);
      border-radius: 50%;
      border-top: 2px solid var(--bid-color);
      width: 12px;
      height: 12px;
      animation: spin 1s linear infinite;
      display: inline-block;
      vertical-align: middle;
      margin-left: 5px;
    }
    
    .panel-alert {
      position: absolute;
      top: 5px;
      font-size: 11px;
      font-weight: bold;
      padding: 2px 5px;
      border-radius: 3px;
      animation: flash 1s ease-in-out;
      z-index: 100;
    }
    
    .ask-alert {
      right: 10px;
      color: var(--ask-color);
      background-color: rgba(255, 85, 85, 0.2);
    }
    
    .bid-alert {
      left: 10px;
      color: var(--bid-color);
      background-color: rgba(85, 255, 85, 0.2);
    }
    
    .liquidity-controls {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      padding: 5px;
      background-color: var(--panel-color);
      border-radius: 5px;
    }
    
    .liquidity-thresholds {
      display: flex;
      gap: 5px;
      align-items: center;
    }
    
    .liquidity-btn {
      background-color: var(--panel-color);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      padding: 5px 8px;
      font-size: 12px;
      border-radius: 5px;
      cursor: pointer;
    }
    
    /* Contenedor principal de estad√≠sticas */
    .market-stats-container {
      background-color: var(--panel-color);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .stats-panel h3 {
      margin: 0 0 10px 0;
      color: var(--text-color);
      font-size: 14px;
      text-align: center;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-color);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 15px;
      margin-bottom: 12px;
    }

    .stats-column {
      padding: 8px;
      border-radius: 6px;
    }

    .bid-stats {
      background-color: rgba(85, 255, 85, 0.1);
      border-left: 3px solid var(--bid-color);
    }

    .ask-stats {
      background-color: rgba(255, 85, 85, 0.1);
      border-left: 3px solid var(--ask-color);
    }

    .spread-stats {
      background-color: rgba(255, 255, 0, 0.1);
      border-left: 3px solid #ffff00;
    }

    /* Barra de desequilibrio mejorada */
    .imbalance-container {
      margin-top: 15px;
      padding: 10px;
      background-color: rgba(0,0,0,0.2);
      border-radius: 6px;
      text-align: center;
    }

    .imbalance-label {
      font-size: 12px;
      color: var(--text-secondary);
      margin-right: 8px;
    }

    .imbalance-value {
      font-weight: bold;
      font-size: 13px;
    }

    .imbalance-bar {
      height: 12px;
      background: linear-gradient(to right, var(--ask-color), var(--bid-color));
      border-radius: 6px;
      margin-top: 8px;
      position: relative;
    }

    .imbalance-indicator {
      position: absolute;
      height: 16px;
      width: 3px;
      background-color: white;
      top: -2px;
      transform: translateX(-50%);
      border-radius: 2px;
    }

    /* Alertas */
    .alert-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      max-width: 300px;
      z-index: 1000;
    }

    .market-alert {
      padding: 8px 12px;
      margin: 5px 0;
      border-radius: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      animation: fadeIn 0.3s ease;
      font-size: 12px;
      background-color: var(--panel-color);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .alert-time {
      color: var(--text-secondary);
      font-size: 10px;
      margin-right: 8px;
    }

    .alert-message {
      flex-grow: 1;
    }

    .alert-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 14px;
      margin-left: 8px;
    }

    .spread-alert {
      border-left: 3px solid orange;
    }

    .imbalance-alert {
      border-left: 3px solid mediumpurple;
    }

    .volume-alert {
      border-left: 3px solid deepskyblue;
    }

    /* Controles de liquidez en estad√≠sticas */
    .liquidity-controls-stats {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
      padding: 10px;
      background-color: rgba(0,0,0,0.2);
      border-radius: 6px;
    }

    .liquidity-thresholds-stats {
      display: flex;
      gap: 5px;
      align-items: center;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Responsive */
    @media (max-width: 768px) {
      .header-controls {
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }
      
      .header-left, .header-center, .interval-selector {
        width: 100%;
        justify-content: center;
        text-align: center;
      }
      
      .search-container {
        width: 100%;
      }
      
      .search-container input {
        width: 80%;
      }
      
      .panel {
        min-width: 100%;
      }
      
      .symbol-title {
        margin-left: 0;
        margin-top: 8px;
      }
      
      .liquidity-controls {
        flex-direction: column;
        gap: 5px;
      }
      
      .stats-grid {
        grid-template-columns: 1fr;
      }
      
      .alert-container {
        bottom: 10px;
        right: 10px;
        left: 10px;
        max-width: none;
      }
    }

    @keyframes flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* ========== ESTILOS PARA CLUSTERS ========== */
    .tradingview-lightweight-charts-marker-tooltip {
      font-family: 'Courier New', monospace !important;
      font-size: 10px !important;
      background: rgba(40, 40, 40, 0.95) !important;
      border: 1px solid #444 !important;
      border-radius: 4px !important;
      padding: 4px 6px !important;
      line-height: 1.4 !important;
      white-space: nowrap !important;
      color: #FFFFFF !important;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3) !important;
    }

    /* Contenedor de alertas */
    #alert-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      max-width: 300px;
      z-index: 1000;
    }

    /* Alertas individuales */
    .market-alert {
      padding: 10px 15px;
      margin: 8px 0;
      background: var(--panel-color);
      border-radius: 4px;
      display: flex;
      align-items: center;
      animation: fadeIn 0.3s ease;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }

    .alert-time {
      color: var(--text-secondary);
      font-size: 10px;
      margin-right: 10px;
    }

    .alert-icon {
      font-size: 16px;
      margin-right: 10px;
      font-weight: bold;
    }

    .alert-message {
      flex-grow: 1;
      font-size: 12px;
    }

    .alert-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 16px;
      margin-left: 10px;
    }

    /* Animaciones */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .fade-out {
      animation: fadeOut 0.5s ease forwards;
    }

    @keyframes fadeOut {
      to { opacity: 0; transform: translateY(10px); }
    }

       /* CELDA DE SELECCI√ìN */
    .selected-column {
        cursor: pointer;
        user-select: none;
    }

    /* checkbox NO recibe clic ‚Äî el TD s√≠ */
    .selected-column input.selection-checkbox {
        pointer-events: none !important;
    }

    /* Congelar la fila cuando el mouse est√° encima */
    tr.freeze-row * {
        transition: none !important;
    }

        /* üî• FIX CLICK SEL ‚Äî evita que la celda sea destruida mientras haces clic */
    .selected-column.freeze {
        pointer-events: auto !important;
        background-color: rgba(255,255,0,0.07);
        transition: background-color 0.05s linear;
    }



  
  </style>
  <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
  <div class="header-controls">
    <div class="header-left">
      <div class="search-container">
        <label for="symbol-search">Buscar par USDT:</label>
        <input type="text" id="symbol-search" placeholder="Ejemplo: BTCUSDT" list="symbol-list" autocomplete="off" aria-label="Buscar par de trading">
        <datalist id="symbol-list"></datalist>
      </div>
      <h1 class="symbol-title" id="symbol-title"></h1>
    </div>
    
    <div class="header-center">
      <p class="header-info-line" id="compact-timestamp"></p>
      <p class="header-info-line">√ìrdenes procesadas: <span id="total-prices">0</span></p>
      <p class="header-info-line" id="ws-status">WebSocket: Conectando... <span class="spinner"></span></p>
    </div>
    
    <div class="interval-selector">
      <label for="interval-select">Intervalo: </label>
      <select id="interval-select" aria-label="Seleccionar intervalo de velas">
        <option value="15m">15m</option>
        <option value="1h" selected>1h</option>
        <option value="4h">4h</option>
        <option value="1d">1d</option>
      </select>
      <button onclick="autoScaleChart()" aria-label="Autoajustar gr√°fico">Auto Scale</button>
    </div>
  </div>
  
  <div class="chart-container" id="chart-container">
    <div class="loading-message">Cargando gr√°fico... <span class="spinner"></span></div>
  </div>
  
  <div id="error-message" class="error-message"></div>
  
  <!-- Nuevo contenedor de estad√≠sticas de mercado -->
  <div class="market-stats-container">
    <div class="stats-panel">
      <h3>Estad√≠sticas de Mercado</h3>
      <div class="stats-grid">
        <!-- Columna Asks (izquierda) -->
        <div class="stats-column ask-stats">
          <div class="stats-row">
            <span class="stats-label">Liquidez Asks:</span>
            <span class="stats-value" id="total-ask-liquidity">0</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">√ìrdenes grandes:</span>
            <span class="stats-value" id="large-asks-count">0</span>
          </div>
        </div>
        
        <!-- Columna Spread -->
        <div class="stats-column spread-stats">
          <div class="stats-row">
            <span class="stats-label">Spread:</span>
            <span class="stats-value" id="market-spread">0</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">Best Bid/Ask:</span>
            <span class="stats-value" id="best-bid-ask">0 / 0</span>
          </div>
        </div>
        
        <!-- Columna Bids (derecha) -->
        <div class="stats-column bid-stats">
          <div class="stats-row">
            <span class="stats-label">Liquidez Bids:</span>
            <span class="stats-value" id="total-bid-liquidity">0</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">√ìrdenes grandes:</span>
            <span class="stats-value" id="large-bids-count">0</span>
          </div>
        </div>
      </div>
      
      <!-- Barra de desequilibrio mejorada -->
      <div class="imbalance-container">
        <span class="imbalance-label">Desequilibrio:</span>
        <span class="imbalance-value" id="orderbook-imbalance">0%</span>
        <div class="imbalance-bar">
          <div class="imbalance-indicator" id="imbalance-indicator"></div>
        </div>
      </div>
      
      <!-- Controles de liquidez en la secci√≥n de estad√≠sticas -->
      <div class="liquidity-controls-stats">
        <div class="liquidity-thresholds-stats">
          <label>Umbral:</label>
          <input type="number" id="large-threshold" value="50000000" step="1000000">
          <label>Muy grande:</label>
          <input type="number" id="very-large-threshold" value="100000000" step="1000000">
          <button class="liquidity-btn" onclick="updateThresholds()">Aplicar</button>
        </div>
        <div>
          <button class="liquidity-btn" onclick="toggleSoundAlerts()" id="sound-toggle">üîä Sonido: ON</button>
          <button class="liquidity-btn" onclick="toggleClusters()" id="cluster-toggle">üìä Mostrar Clusters</button>
          <button class="liquidity-btn" onclick="toggleLiquidityHeatmap()">Heatmap</button>
          <button class="liquidity-btn" onclick="saveKeyLevels()">Guardar Niveles</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Contenedor de alertas -->
  <div id="alert-container" class="alert-container"></div>
  
  <div class="container">
    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="asks-indicator-start"></span>
        <h2 class="asks-title">Top Asks (Futuros)</h2>
        <span class="processed-count asks-processed" id="asks-processed">0</span>
        <span class="indicator-circle indicator-circle-end" id="asks-indicator-end"></span>
      </div>
      
      <table aria-label="√ìrdenes de venta">
        <thead>
          <tr>
            <th>#</th>
            <th>Age</th>
            <th>Price</th>
            <th>Qty</th>
            <th>Usdt</th>
            <th>% Mark</th>
            <th>Hits</th>
            <th class="selected-column">Sel</th>
          </tr>
        </thead>
        <tbody id="asks-body" aria-live="polite" aria-atomic="false"></tbody>
      </table>
      
      <div class="legend">
        <div class="legend-row" style="background-color: var(--highlight-ask) !important; color: var(--text-color) !important;">Ask actualizado (Venta)</div>
        <div class="legend-row" style="background-color: var(--color-purple) !important; color: var(--text-color) !important;">√ìrdenes institucionales</div>
      </div>
    </div>
    
    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="bids-indicator-start"></span>
        <h2>Top Bids (Futuros)</h2>
        <span class="processed-count bids-processed" id="bids-processed">0</span>
        <span class="indicator-circle indicator-circle-end" id="bids-indicator-end"></span>
      </div>
      
      <table aria-label="√ìrdenes de compra">
        <thead>
          <tr>
            <th>#</th>
            <th>Age</th>
            <th>Price</th>
            <th>Qty</th>
            <th>Usdt</th>
            <th>% Mark</th>
            <th>Hits</th>
            <th class="selected-column">Sel</th>
          </tr>
        </thead>
        <tbody id="bids-body" aria-live="polite" aria-atomic="false"></tbody>
      </table>
      
      <div class="legend">
        <div class="legend-row bid-updated-legend" style="background-color: var(--bid-color) !important; color: #000000 !important;">Bid actualizado (Compra)</div>
        <div class="legend-row" style="background-color: var(--color-purple) !important; color: var(--text-color) !important;">√ìrdenes institucionales</div>
      </div>
    </div>
  </div>

  <script>
    // Configuraci√≥n inicial
    const params = new URLSearchParams(window.location.search);
    const symbol = params.get("symbol") || "BTCUSDT";
    document.getElementById("symbol-title").innerText = `${symbol}: 0.0000 USDT`;
    
    // URLs de WebSocket
    const futuresWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@depth@100ms`;
    const futuresMarkPriceWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@markPrice@1s`;
    const tickerWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@ticker`;
    
    // Variables de estado
    let markPriceFutures = 0;
    let lastPriceUpdate = 0;
    let futuresAsksData = [];
    let futuresBidsData = [];
    let asksProcessed = 0;
    let bidsProcessed = 0;
    let pendingUpdate = false;
    let updatePaused = false;
    let isInteracting = false;
    const rowColors = new Map();
    const COLOR_DURATION_MS = 5000;
    let selectedPrices = new Map();
    let currentInterval = localStorage.getItem('chartInterval') || '1h';
    document.getElementById('interval-select').value = currentInterval;
    let asksPriceMap = new Map();
    let bidsPriceMap = new Map();
    let chart = null;
    let candlestickSeries = null;
    let emaSeries = null;
    let candlesData = [];
    let lastChartUpdate = 0;
    const CHART_UPDATE_INTERVAL = 1000;
    let klineSocket = null;
    let lastCandle = null;
    let lastAlertElement = null;
    let LARGE_ORDER_THRESHOLD = 50000000; // 50 millones USDT
    let VERY_LARGE_ORDER_THRESHOLD = 100000000; // 100 millones USDT
    let liquidityHistory = [];
    const MAX_HISTORY = 100;
    let heatmapEnabled = false;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    let clustersVisible = false;
    let currentMarkers = [];
    let currentPriceLines = [];
    let previousAsks = new Map();
    let previousBids = new Map();
    let institutionalMarkers = [];
    let institutionalLines = new Map();    // price ‚Üí lineId
    let institutionalPanel = [];           // panel lateral   
    let institutionalMemory = new Map();  // ‚Üê FALTABA ESTA
    let lastSpreadAlertTime = 0;
    let spreadAlertElement = null;

     

    // ===== SPOOF DETECTOR =====
    let spoofMemory = new Map();

    const SPOOF_MIN_USDT = 5000000; // 50M USDT m√≠nimo para spoof
    const SPOOF_MAX_MS = 1500;       // duraci√≥n m√°xima para considerarlo spoof

    function detectSpoof(isAsk, now) {

      const current = isAsk ? futuresAsksData : futuresBidsData;
      const previous = isAsk ? previousAsks : previousBids;
      const side = isAsk ? "ASK" : "BID";

      // Convertimos precios actuales en un Set
      const currentPrices = new Set(current.map(o => o.price));

      // 1. Detectar desaparici√≥n de √≥rdenes grandes
      previous.forEach((order, price) => {

        // Si una orden grande desapareci√≥
        if (!currentPrices.has(price)) {
          const elapsed = now - order.time;

          if (order.usdt >= SPOOF_MIN_USDT && elapsed <= SPOOF_MAX_MS) {
            console.log(
              `%cüî• SPOOF DETECTADO | ${side} | Precio: ${price} | ` +
              `Valor: ${order.usdt.toFixed(0)} USD | Duraci√≥n: ${elapsed}ms`,
              "background:red;color:white;font-weight:bold;padding:5px"
            );
          }
        }
      });

      // 2. Guardar snapshot actual
      const map = new Map();
      current.forEach(o => {
        map.set(o.price, { time: now, usdt: o.usdt });
      });

      if (isAsk) previousAsks = map;
      else previousBids = map;
    }

    // Configuraci√≥n de alertas
    const ALERT_SETTINGS = {
      spreadAlert: 0.5, // % para considerar spread alto
      imbalanceAlert: 30, // % de desequilibrio para alerta
      volumeAlert: 100000000, // 100M USDT para alerta de volumen
      soundEnabled: true
    };
    
    // Elementos del DOM
    const errorMessageElement = document.getElementById("error-message");
    
    // Cargar precios seleccionados desde localStorage
    function loadSelectedPrices() {
      const savedPrices = JSON.parse(localStorage.getItem(`selectedPrices_${symbol}`) || '[]');
      selectedPrices.clear();
      savedPrices.forEach(price => selectedPrices.set(price, { series: null, isAsk: false }));
    }
    
    // Inicializar WebSockets con manejo de reconexi√≥n
    function initializeWebSockets() {
      initializeTickerSocket();
      initializeMarkPriceSocket();
      initializeDepthSocket();
      initializeChart();
      initializeKlineSocket();
    }
    
    // WebSocket para ticker (precio actual)
    function initializeTickerSocket() {
      const socket = new WebSocket(tickerWsUrl);
      
      socket.onopen = () => {
        updateWsStatus(`WebSocket: Conectado (Ticker)`);
      };
      
      socket.onerror = (error) => {
        showError(`Error en Ticker WebSocket: ${error.message || 'Desconocido'}`);
      };
      
      socket.onclose = () => {
        updateWsStatus("WebSocket: Reconectando (Ticker)...");
        setTimeout(initializeTickerSocket, 3000);
      };
      
      socket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          const now = Date.now();
          
          if (data.c) {
            const newPrice = parseFloat(data.c);
            markPriceFutures = newPrice;
            lastPriceUpdate = now;
            document.getElementById("symbol-title").innerText = `${symbol}: ${formatPrice(markPriceFutures)} USDT`;
            updateTimestamp();
            scheduleTableUpdate();
            updateMarketSpread();
          }
        } catch (err) {
          showError(`Error al procesar mensaje de Ticker: ${err.message}`);
        }
      };
    }
    
    // WebSocket para mark price
    function initializeMarkPriceSocket() {
      const socket = new WebSocket(futuresMarkPriceWsUrl);
      
      socket.onopen = () => {
        updateWsStatus(`WebSocket: Conectado (Mark Price)`);
      };
      
      socket.onerror = (error) => {
        showError(`Error en Mark Price WebSocket: ${error.message || 'Desconocido'}`);
      };
      
      socket.onclose = () => {
        updateWsStatus("WebSocket: Reconectando (Mark Price)...");
        setTimeout(initializeMarkPriceSocket, 3000);
      };
      
      socket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.s === symbol.toUpperCase()) {
            markPriceFutures = parseFloat(data.p);
            lastPriceUpdate = Date.now();
            document.getElementById("symbol-title").innerText = `${symbol}: ${formatPrice(markPriceFutures)} USDT`;
            updateMarketSpread();
          }
        } catch (err) {
          showError(`Error al procesar mensaje de Mark Price: ${err.message}`);
        }
      };
    }
    
    // WebSocket para depth (libro de √≥rdenes)
    function initializeDepthSocket() {
      const socket = new WebSocket(futuresWsUrl);

      socket.onopen = () => {
        updateWsStatus(`WebSocket: Conectado (Depth)`);
      };

      socket.onerror = (error) => {
        showError(`Error en Depth WebSocket: ${error.message || 'Desconocido'}`);
      };

      socket.onclose = () => {
        updateWsStatus("WebSocket: Reconectando (Depth)...");
        setTimeout(initializeDepthSocket, 3000);
      };

      socket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          const now = Date.now();

          // -----------------------------
          //           ASKS
          // -----------------------------
          if (data.a && Array.isArray(data.a)) {

            futuresAsksData = updateOrders(futuresAsksData, data.a, now, true);

            detectSpoof(true, now);

            asksProcessed += data.a.length;

            data.a.forEach(([p, q]) => {
              const price = parseFloat(p);
              const quantity = parseFloat(q);
              const usdtValue = price * quantity;

              if (usdtValue >= VERY_LARGE_ORDER_THRESHOLD) {
                showOrderAlert('ask', usdtValue, true);
                addChartInstitutionalAlert(price, "ask", usdtValue);   // ‚úî AGREGADO
              } 
              else if (usdtValue >= LARGE_ORDER_THRESHOLD) {
                showOrderAlert('ask', usdtValue, false);
                addChartInstitutionalAlert(price, "ask", usdtValue);   // ‚úî AGREGADO
              }
            });
          }

          // -----------------------------
          //           BIDS
          // -----------------------------
          if (data.b && Array.isArray(data.b)) {

            futuresBidsData = updateOrders(futuresBidsData, data.b, now, false);

            detectSpoof(false, now);

            bidsProcessed += data.b.length;

            data.b.forEach(([p, q]) => {
              const price = parseFloat(p);
              const quantity = parseFloat(q);
              const usdtValue = price * quantity;

              if (usdtValue >= VERY_LARGE_ORDER_THRESHOLD) {
                showOrderAlert('bid', usdtValue, true);
                addChartInstitutionalAlert(price, "bid", usdtValue);   // ‚úî AGREGADO
              } 
              else if (usdtValue >= LARGE_ORDER_THRESHOLD) {
                showOrderAlert('bid', usdtValue, false);
                addChartInstitutionalAlert(price, "bid", usdtValue);   // ‚úî AGREGADO
              }
            });
          }

          updateProcessedCounters();
          updateLiquidityStats();
          updateOrderBookImbalance();
          trackLiquidityChanges();
          updateTables();

        } catch (err) {
          showError(`Error al procesar mensaje de Depth: ${err.message}`);
        }
      };
    }

    function detectSpoof(isAsk, now) {

      const orders = isAsk ? futuresAsksData : futuresBidsData;

      orders.forEach(order => {

        const price = order.price;
        const qty   = order.qty;
        const usdt  = order.usdt;

        const key = `${isAsk ? "ASK" : "BID"}_${price}`;

        // ---- ORDEN GRANDE APARECE ----
        if (qty > 0 && usdt >= SPOOF_MIN_USDT) {

          if (!spoofMemory.has(key)) {

            spoofMemory.set(key, {
              time: now,
              usdt: usdt,
              side: isAsk ? "ASK" : "BID"
            });

            console.log(
              `%cüü® ORDEN GRANDE (${isAsk ? "ASK" : "BID"}) APARECE | ${price} | ${usdt.toFixed(0)} USD`,
              "color: orange; font-weight: bold"
            );
          }

          return;
        }

        // ---- ORDEN DESAPARECE (SPOOF) ----
        if (qty === 0 && spoofMemory.has(key)) {

          const info = spoofMemory.get(key);
          const duration = now - info.time;

          if (duration <= SPOOF_MAX_MS) {
            console.log(
              `%cüî• SPOOF DETECTADO (${info.side}) | Precio: ${price} | Valor: ${info.usdt.toFixed(0)} USD | Duraci√≥n: ${duration} ms`,
              "background:red; color:white; font-weight:bold; padding:3px;"
            );
          }

          spoofMemory.delete(key);
        }

      });

    }

    // WebSocket para velas en tiempo real
    function initializeKlineSocket() {

        // === VALIDAR INTERVALO PARA EVITAR WEBSOCKET INVALIDO ===
        const validIntervals = [
            "1m","3m","5m","15m","30m",
            "1h","2h","4h",
            "1d","1w","1M"
        ];

        if (!validIntervals.includes(currentInterval)) {
            console.warn("‚õî Intervalo inv√°lido detectado:", currentInterval, "‚Üí se cambia a 1h");
            currentInterval = "1h";
            localStorage.setItem("chartInterval", "1h");
        }

        // ==== CERRAR SOCKET ANTERIOR ====
        if (klineSocket) {
            try { klineSocket.close(); } catch(e){}
        }

        // ==== CREAR URL FINAL ====
        const wsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${currentInterval}`;
        console.log("üîå Conectando Kline WS:", wsUrl);

        klineSocket = new WebSocket(wsUrl);

        // ==== AL CONECTAR ====
        klineSocket.onopen = () => {
            updateWsStatus(`WebSocket: Conectado (Kline)`);
            reconnectAttempts = 0;
            loadHistoricalKlines();
        };

        // ==== ERROR ====
        klineSocket.onerror = (error) => {
            console.warn("‚ùå Error WebSocket Kline:", error);

            showError(`Error en Kline WebSocket: ${error.message || 'Error desconocido'}`);

            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                reconnectAttempts++;
                setTimeout(initializeKlineSocket, delay);
            } else {
                showError("Maximo de reconexiones alcanzado. Recargue la p√°gina.");
            }
        };

        // ==== CIERRE ====
        klineSocket.onclose = () => {
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                updateWsStatus("WebSocket: Reconectando (Kline)...");
                reconnectAttempts++;
                setTimeout(initializeKlineSocket, 3000);
            }
        };

        // ==== MENSAJES ====
        klineSocket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                const kline = data.k;

                const newCandle = {
                    time: Math.floor(kline.t / 1000),
                    open: parseFloat(kline.o),
                    high: parseFloat(kline.h),
                    low: parseFloat(kline.l),
                    close: parseFloat(kline.c)
                };

                if (kline.x) {
                    // Cerrada
                    if (candlesData[candlesData.length - 1]?.time === newCandle.time) {
                        candlesData[candlesData.length - 1] = newCandle;
                    } else {
                        candlesData.push(newCandle);
                        if (candlesData.length > 150) candlesData.shift();
                    }
                } else {
                    // En progreso
                    if (candlesData[candlesData.length - 1]?.time === newCandle.time) {
                        candlesData[candlesData.length - 1] = newCandle;
                    } else {
                        candlesData.push(newCandle);
                        if (candlesData.length > 150) candlesData.shift();
                    }
                }

                // Actualizar el gr√°fico
                if (candlestickSeries) {
                    candlestickSeries.setData(candlesData);

                    const ema100 = calculateEMA(candlesData, 100);
                    if (emaSeries) emaSeries.setData(ema100);
                }

            } catch (err) {
                console.error(err);
                showError(`Error al procesar mensaje de Kline: ${err.message}`);
            }
        };
    }

    
    // Mostrar alerta visual para √≥rdenes institucionales
    function showOrderAlert(type, value, isVeryLarge) {
      const panelTitle = document.querySelector(`.${type}s-title`);
      if (!panelTitle) return;
      
      const panel = panelTitle.closest('.panel');
      if (!panel) return;
      
      const alertElement = document.createElement('div');
      alertElement.className = `panel-alert ${type}-alert`;
      alertElement.textContent = `${type === 'ask' ? 'SELL' : 'BUY'}: ${formatUsdt(value)}`;
      
      panel.appendChild(alertElement);
      
      if (lastAlertElement && lastAlertElement.parentNode) {
        lastAlertElement.remove();
      }
      
      lastAlertElement = alertElement;
      
      if (ALERT_SETTINGS.soundEnabled) {
        playAlertSound(isVeryLarge ? 'volume' : 'default');
      }
      
      setTimeout(() => {
        if (alertElement && alertElement.parentNode) {
          alertElement.remove();
        }
      }, 5000);
      
      if (isVeryLarge && chart) {
        const price = type === 'ask' 
          ? futuresAsksData.find(a => a.usdt === value)?.price 
          : futuresBidsData.find(b => b.usdt === value)?.price;
        
        if (price) {
          addChartInstitutionalAlert(price, type, value);
        }
      }
    }
    

    // ==============================================
    //     üöÄ ZDL - ALERTAS INSTITUCIONALES PRO
    //     Top 3 reales + Anti-duplicados
    // ==============================================

    let lastInstitutional = { price: null, value: null, time: 0 };


    function addChartInstitutionalAlert(price, type, value) {
        if (!candlestickSeries) return;

        const key = `${type}_${price}`;

        // ============================================
        // üö´ EVITAR ALERTAS DUPLICADAS EN EL MISMO PRECIO
        // ============================================
        const lastValue = institutionalMemory.get(key);

        // Si la alerta ya existe y el valor es casi igual ‚Üí ignorar
        if (lastValue && Math.abs(lastValue - value) < 5_000_000) {
            return;
        }

        // Guardamos el valor
        institutionalMemory.set(key, value);


        // ============================================
        // üé® COLOR FINAL POR TIPO
        // ============================================
        // BID ‚Üí verde
        // ASK ‚Üí rojo
        let color = type === "ask" ? "#ff3333" : "#00ff55";


        // ============================================
        // üìê TAMA√ëO SEG√öN MONTOS
        // ============================================
        let size = 0.6;   // base

        if (value >= 100_000_000) size = 0.9;
        if (value >= 300_000_000) size = 1.2;


        // ============================================
        // üìç POSICI√ìN SEG√öN TIPO
        // ============================================
        const position = type === "ask" ? "aboveBar" : "belowBar";
        const shape    = type === "ask" ? "arrowDown" : "arrowUp";


        // ============================================
        // üî• CREAR MARCADOR
        // ============================================
        const marker = {
            time: Math.floor(Date.now() / 1000),
            position,
            color,
            shape,
            text: `${type.toUpperCase()} ‚Ä¢ ${formatUsdt(value)}`,
            size
        };

        institutionalMarkers.push(marker);


        // ============================================
        // üîù SOLO LAS 3 M√ÅS IMPORTANTES
        // ============================================
        institutionalMarkers = institutionalMarkers
            .sort((a, b) => {
                const va = parseFloat(a.text.split("‚Ä¢")[1]);
                const vb = parseFloat(b.text.split("‚Ä¢")[1]);
                return vb - va;
            })
            .slice(0, 3);


        // ============================================
        // üñºÔ∏è DIBUJAR EN EL GR√ÅFICO
        // ============================================
        candlestickSeries.setMarkers(institutionalMarkers);


        // ============================================
        // ‚è≥ LIMPIAR DESPU√âS DE 20 SEGUNDOS
        // ============================================
        setTimeout(() => {
            institutionalMarkers = institutionalMarkers.filter(m => m.time !== marker.time);
            candlestickSeries.setMarkers(institutionalMarkers);
        }, 20_000);
    }

    function addInstitutionalLine(price, color) {
        if (!chart) return;

        // Si ya existe, no duplicar
        if (institutionalLines.has(price)) return;

        const line = chart.addPriceLine({
            price,
            color,
            lineWidth: 2,
            lineStyle: 2 // dashed
        });

        institutionalLines.set(price, line);

        // Remover la l√≠nea autom√°ticamente cuando el precio la toque
        const watcher = setInterval(() => {
            if (!markPriceFutures) return;

            const diff = Math.abs(markPriceFutures - price);
            if (diff <= (0.5)) {      // dentro de $0.5 ‚Üí consumida
                chart.removePriceLine(line);
                institutionalLines.delete(price);
                clearInterval(watcher);
            }
        }, 500);
    }
    
    // Actualizar √≥rdenes con nuevos datos
    function updateOrders(existingOrders, newOrders, now, isAsk) {
      const orderMap = new Map(existingOrders.map(o => [o.price, o]));
      
      newOrders.forEach(([p, q]) => {
        const price = parseFloat(p);
        const quantity = parseFloat(q);
        const usdtValue = price * quantity;
        
        if (quantity === 0) {
          orderMap.delete(price);
          rowColors.delete(price);
        } else {
          const existingOrder = orderMap.get(price);
          
          if (existingOrder) {
            existingOrder.qty = quantity;
            existingOrder.usdt = usdtValue;
            existingOrder.lastUpdated = now;
            existingOrder.hits = (existingOrder.hits || 0) + 1;
            existingOrder.colorAssignedTime = now;
          } else {
            orderMap.set(price, {
              price: price,
              qty: quantity,
              usdt: usdtValue,
              lastUpdated: now,
              colorAssignedTime: now,
              hits: 1
            });
          }
        }
      });
      
      return Array.from(orderMap.values())
        .filter(order => order.usdt > 100)
        .sort((a, b) => b.usdt - a.usdt)
        .slice(0, 20);
    }
    
    // Actualizar tablas de bids y asks
    function updateTable(tableId, data, isAsk) {
        const tableBody = document.getElementById(tableId);
        if (!tableBody) return;

        const now = Date.now();
        const existingRows = new Map();

        // Guardar filas existentes
        Array.from(tableBody.children).forEach(row => {
            const priceCell = row.querySelector(".price-cell");
            if (priceCell) {
                const price = parseFloat(priceCell.textContent);
                existingRows.set(price, row);
            }
        });

        const fragment = document.createDocumentFragment();

        data.forEach((item, index) => {
            const age = formatAge(now - item.lastUpdated);
            const percentage = markPriceFutures ?
                (((item.price - markPriceFutures) / markPriceFutures) * 100).toFixed(3) + "%" :
                "---";

            let row = existingRows.get(item.price);

            // Si no existe, crearla UNA SOLA VEZ
            if (!row) {
                row = document.createElement("tr");
                row.className = isAsk ? "ask-row" : "bid-row";

                row.innerHTML = `
                    <td><span></span></td>
                    <td class="age-cell"><span></span></td>
                    <td class="price-cell"><span></span></td>
                    <td><span></span></td>
                    <td><span></span></td>
                    <td><span></span></td>
                    <td><span></span></td>

                    <td class="selected-column">
                        <input type="checkbox" class="selection-checkbox">
                    </td>
                `;

                // üî• AQU√ç EST√Å EL FIX DEL CLICK üî•
                row.querySelector(".selected-column").onclick = (e) =>
                    handleSelectClick(e, item.price, isAsk);
            }

            // Actualizar celdas
            const cells = row.children;
            cells[0].firstElementChild.textContent = index + 1;
            cells[1].firstElementChild.textContent = age;
            cells[2].firstElementChild.textContent = formatPrice(item.price);
            cells[3].firstElementChild.textContent = formatQuantity(item.qty);
            cells[4].firstElementChild.textContent = formatUsdt(item.usdt);
            cells[5].firstElementChild.textContent = percentage;
            cells[6].firstElementChild.textContent = item.hits;

            // Checkbox reflejando selecci√≥n
            const cb = cells[7].querySelector(".selection-checkbox");
            cb.checked = selectedPrices.has(item.price);

            // Estilos
            if (index < 5) row.classList.add("bold-row");
            else row.classList.remove("bold-row");

            if (item.usdt >= LARGE_ORDER_THRESHOLD)
                row.classList.add("color-purple", "bold-row");
            else
                row.classList.remove("color-purple");

            const recentlyUpdated = item.lastUpdated && (now - item.lastUpdated) <= 1000;

            if (recentlyUpdated) {
                const highlightClass = isAsk ? "highlight-red" : "highlight-green";
                row.classList.add(highlightClass);

                setTimeout(() => {
                    row.classList.remove(highlightClass);
                    if (item.usdt >= LARGE_ORDER_THRESHOLD)
                        row.classList.add("color-purple", "bold-row");
                }, 1000);
            }

            if (selectedPrices.has(item.price))
                row.classList.add("selected-row");
            else
                row.classList.remove("selected-row");

            fragment.appendChild(row);
            existingRows.delete(item.price);
        });

        // Eliminar filas que ya no existen
        existingRows.forEach((row, price) => {
            rowColors.delete(price);
            row.remove();
        });

        // Insertar filas actualizadas
        tableBody.innerHTML = "";
        tableBody.appendChild(fragment);

        redrawSelectedLines();
    }



        // === FUNCI√ìN FALTANTE ===
    // Actualiza ambas tablas: ASKS y BIDS
    function updateTables() {
      updateTable("asks-body", futuresAsksData, true);
      updateTable("bids-body", futuresBidsData, false);
    }    
       
    // Funci√≥n simplificada para colores
    function getColorClass(item, now) {
      if (item.usdt >= LARGE_ORDER_THRESHOLD) {
        return "color-purple";
      }
      return "color-transparent";
    }
    
    // Programar actualizaci√≥n de tablas con debounce
    function scheduleTableUpdate() {
      if (isInteracting) return;

      if (!pendingUpdate) {
        pendingUpdate = true;
        setTimeout(() => {
          if (!isInteracting) {
            updateTables();
          }
          pendingUpdate = false;
        }, 150);
      }
    }
   
    
    // Actualizar contadores de √≥rdenes procesadas
    function updateProcessedCounters() {
      const totalPrices = asksProcessed + bidsProcessed;
      
      document.getElementById("total-prices").innerText = totalPrices.toLocaleString();
      document.getElementById("asks-processed").innerText = asksProcessed.toLocaleString();
      document.getElementById("bids-processed").innerText = bidsProcessed.toLocaleString();
      
      if (totalPrices >= 1000000) {
        document.getElementById("total-prices").classList.add("highlight-total");
      } else {
        document.getElementById("total-prices").classList.remove("highlight-total");
      }
      
      const askIndicatorStart = document.getElementById("asks-indicator-start");
      const askIndicatorEnd = document.getElementById("asks-indicator-end");
      const bidIndicatorStart = document.getElementById("bids-indicator-start");
      const bidIndicatorEnd = document.getElementById("bids-indicator-end");
      
      if (askIndicatorStart && askIndicatorEnd && bidIndicatorStart && bidIndicatorEnd) {
        askIndicatorStart.classList.remove("circle-red", "circle-green");
        askIndicatorEnd.classList.remove("circle-red", "circle-green");
        bidIndicatorStart.classList.remove("circle-red", "circle-green");
        bidIndicatorEnd.classList.remove("circle-red", "circle-green");
        
        if (asksProcessed > bidsProcessed) {
          askIndicatorStart.classList.add("circle-red");
          askIndicatorEnd.classList.add("circle-red");
        } else if (bidsProcessed > asksProcessed) {
          bidIndicatorStart.classList.add("circle-green");
          bidIndicatorEnd.classList.add("circle-green");
        }
      }
      
      scheduleTableUpdate();
    }
    
    // Actualizar estad√≠sticas de liquidez
    function updateLiquidityStats() {
      const totalAskLiquidity = futuresAsksData.reduce((sum, order) => sum + order.usdt, 0);
      const totalBidLiquidity = futuresBidsData.reduce((sum, order) => sum + order.usdt, 0);
      
      const largeAsksCount = futuresAsksData.filter(order => order.usdt >= LARGE_ORDER_THRESHOLD).length;
      const largeBidsCount = futuresBidsData.filter(order => order.usdt >= LARGE_ORDER_THRESHOLD).length;
      
      document.getElementById("total-ask-liquidity").textContent = formatUsdt(totalAskLiquidity);
      document.getElementById("total-bid-liquidity").textContent = formatUsdt(totalBidLiquidity);
      document.getElementById("large-asks-count").textContent = largeAsksCount;
      document.getElementById("large-bids-count").textContent = largeBidsCount;
    }
    
    // Calcular y mostrar desequilibrio del libro de √≥rdenes
    function updateOrderBookImbalance() {
      const totalBidLiquidity = futuresBidsData.reduce((sum, order) => sum + order.usdt, 0);
      const totalAskLiquidity = futuresAsksData.reduce((sum, order) => sum + order.usdt, 0);
      const totalLiquidity = totalBidLiquidity + totalAskLiquidity;
      
      if (totalLiquidity > 0) {
        const imbalance = ((totalBidLiquidity - totalAskLiquidity) / totalLiquidity) * 100;
        document.getElementById("orderbook-imbalance").textContent = `${imbalance.toFixed(2)}%`;
        
        const indicator = document.getElementById("imbalance-indicator");
        if (indicator) {
          const position = (imbalance + 100) / 2;
          indicator.style.left = `${position}%`;
        }
      }
    }
    
    // Actualizar spread del mercado
    function updateMarketSpread() {
      if (futuresBidsData.length > 0 && futuresAsksData.length > 0 && markPriceFutures > 0) {
        const bestBid = futuresBidsData[0].price;
        const bestAsk = futuresAsksData[0].price;
        const spread = bestAsk - bestBid;
        const spreadPercentage = (spread / markPriceFutures) * 100;
        
        document.getElementById("market-spread").textContent = `${formatPrice(spread)} (${spreadPercentage.toFixed(3)}%)`;
        document.getElementById("best-bid-ask").textContent = `${formatPrice(bestBid)} / ${formatPrice(bestAsk)}`;
      }
    }
    
    // Seguimiento de cambios en liquidez
    function trackLiquidityChanges() {
      const snapshot = {
        time: Date.now(),
        bids: futuresBidsData.map(o => ({price: o.price, usdt: o.usdt})),
        asks: futuresAsksData.map(o => ({price: o.price, usdt: o.usdt}))
      };
      
      liquidityHistory.push(snapshot);
      if (liquidityHistory.length > MAX_HISTORY) {
        liquidityHistory.shift();
      }
    }
    
    // Mostrar clusters de liquidez
    function showLiquidityClusters() {
      if (liquidityHistory.length < 3) return;

      const priceLevels = {};
      const priceStep = markPriceFutures * 0.002; // Agrupa precios dentro del 0.2%

      liquidityHistory.slice(-10).forEach(snapshot => {
        [...snapshot.bids, ...snapshot.asks].forEach(order => {
          const roundedPrice = (Math.round(order.price / priceStep) * priceStep).toFixed(2);
          if (!priceLevels[roundedPrice]) {
            priceLevels[roundedPrice] = {
              totalUsdt: 0,
              count: 0,
              type: order.price <= markPriceFutures ? 'bid' : 'ask'
            };
          }
          priceLevels[roundedPrice].totalUsdt += order.usdt;
          priceLevels[roundedPrice].count++;
        });
      });

      const significantClusters = Object.entries(priceLevels)
        .filter(([_, data]) => data.totalUsdt >= LARGE_ORDER_THRESHOLD * 0.5)
        .sort((a, b) => b[1].totalUsdt - a[1].totalUsdt);

      drawClustersOnChart(significantClusters);
    }
    
    // Funci√≥n para dibujar clusters en el gr√°fico
    function drawClustersOnChart(clusters) {
      clearClusters();
      if (!chart || !candlestickSeries || !markPriceFutures) return;

      // Agrupar clusters cercanos para evitar saturaci√≥n
      const groupedClusters = groupNearbyClusters(clusters);
      
      // Limpiar l√≠neas anteriores
      currentPriceLines.forEach(line => {
        try {
          chart.removeSeries(line.series);
        } catch (err) {
          console.warn(`Error al remover serie: ${err.message}`);
        }
      });
      currentPriceLines = [];
      
      // Enfocarnos solo en las zonas de mayor volumen cercanas al precio actual
      const currentPriceThreshold = markPriceFutures * 0.05; // ¬±5% del precio actual
      const filteredClusters = groupedClusters.filter(cluster => 
        Math.abs(cluster.avgPrice - markPriceFutures) <= currentPriceThreshold
      );
      
      // Ordenar por volumen descendente y tomar solo los 3 m√°s grandes
      const topClusters = filteredClusters
        .sort((a, b) => b.totalUsdt - a.totalUsdt)
        .slice(0, 3);
      
      // Dibujar l√≠neas horizontales para los clusters
      const now = Math.floor(Date.now() / 1000);
      
      topClusters.forEach(cluster => {
        const isBid = cluster.type === 'bid';
        const lineSeries = chart.addLineSeries({
          color: isBid ? 'rgba(255, 0, 255, 1)' : 'rgba(255, 0, 255, 1)', // Verde claro para bids, rojo claro para asks
          lineWidth: 2, // L√≠nea m√°s fina
          priceLineVisible: false,
          lastValueVisible: false,
          lineStyle: LightweightCharts.LineStyle.Solid
        });
        
        // L√≠nea en todo el gr√°fico
        lineSeries.setData([
          { time: now - 86400, value: cluster.avgPrice }, // 1 d√≠a atr√°s
          { time: now, value: cluster.avgPrice }
        ]);
        
        // Agregar etiqueta de precio
        const priceLine = {
          price: cluster.avgPrice,
          color: isBid ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)',
          lineWidth: 1,
          lineStyle: LightweightCharts.LineStyle.Solid,
          title: `${formatPrice(cluster.avgPrice)} | ${formatUsdt(cluster.totalUsdt)}`,
          axisLabelVisible: true,
          axisLabelColor: isBid ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)',
          axisLabelTextColor: '#ffffff'
        };
        
        lineSeries.createPriceLine(priceLine);
        currentPriceLines.push({ series: lineSeries, price: cluster.avgPrice });
      });
    }

        // Congela solo la fila mientras el mouse est√° encima
    function enableRowFreeze(tbody) {
        tbody.addEventListener("mouseenter", (e) => {
            const row = e.target.closest("tr");
            if (row) row.classList.add("freeze-row");
        }, true);

        tbody.addEventListener("mouseleave", (e) => {
            const row = e.target.closest("tr");
            if (row) row.classList.remove("freeze-row");
        }, true);
    }

    // Modificaci√≥n para el hover del checkbox
    function setupEventListeners() {
        const asksBody = document.getElementById("asks-body");
        const bidsBody = document.getElementById("bids-body");

        const bindTable = (tbody) => {
            if (!tbody) return;

            if (tbody.dataset.bound === "1") return;
            tbody.dataset.bound = "1";

            // Congela la fila mientras el mouse est√° encima
            enableRowFreeze(tbody);

            // Click para copiar precio
            tbody.addEventListener("click", (e) => {
                const priceCell = e.target.closest(".price-cell");
                if (priceCell) handleTableClick(e);
            });

            // Selecci√≥n del precio con click en la celda SEL
            tbody.addEventListener("click", (e) => {
                const td = e.target.closest(".selected-column");
                if (!td) return;

                const checkbox = td.querySelector(".selection-checkbox");
                if (!checkbox) return;

                // Toggle inmediato
                checkbox.checked = !checkbox.checked;

                // Obtener precio
                const price = parseFloat(td.parentElement.querySelector(".price-cell").textContent);

                const isAsk = (tbody.id === "asks-body");
                togglePriceSelection(price, isAsk, checkbox);
            });
        };

        bindTable(asksBody);
        bindTable(bidsBody);
    }

    // Agrupa clusters cercanos para evitar saturaci√≥n visual
    function groupNearbyClusters(clusters) {
      if (clusters.length === 0) return [];
      
      const priceStep = markPriceFutures * 0.002; // Agrupa precios dentro del 0.2%
      const grouped = [];
      
      // Ordenar por precio
      clusters.sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));
      
      let currentGroup = null;
      
      clusters.forEach(([price, data]) => {
        const priceNum = parseFloat(price);
        
        if (!currentGroup || priceNum - currentGroup.maxPrice > priceStep) {
          // Nuevo grupo
          currentGroup = {
            prices: [priceNum],
            totalUsdt: data.totalUsdt,
            count: 1,
            type: data.type,
            minPrice: priceNum,
            maxPrice: priceNum
          };
          grouped.push(currentGroup);
        } else {
          // Agregar al grupo existente
          currentGroup.prices.push(priceNum);
          currentGroup.totalUsdt += data.totalUsdt;
          currentGroup.count++;
          currentGroup.maxPrice = priceNum;
        }
      });
      
      // Calcular promedio para cada grupo
      return grouped.map(group => ({
        avgPrice: group.prices.reduce((sum, p) => sum + p, 0) / group.prices.length,
        totalUsdt: group.totalUsdt,
        type: group.type,
        count: group.count
      }));
    }

    // Funci√≥n para limpiar clusters
    function clearClusters() {
      if (candlestickSeries) candlestickSeries.setMarkers([]);
      currentMarkers = [];
      
      currentPriceLines.forEach(line => {
        try {
          chart.removeSeries(line.series);
        } catch (err) {
          console.warn(`Error al remover serie: ${err.message}`);
        }
      });
      currentPriceLines = [];
    }

    // Funci√≥n para alternar clusters
    function toggleClusters() {
      clustersVisible = !clustersVisible;
      const button = document.getElementById('cluster-toggle');
      button.textContent = clustersVisible ? '‚ùå Ocultar Clusters' : 'üìä Mostrar Clusters';
      
      if (clustersVisible) {
        showLiquidityClusters();
      } else {
        clearClusters();
      }
    }
    
    // Alternar heatmap de liquidez
    function toggleLiquidityHeatmap() {
      heatmapEnabled = !heatmapEnabled;
      
      if (heatmapEnabled && chart) {
        const heatmapSeries = chart.addHeatmapSeries({
          colorScale: [
            { color: 'rgba(0, 0, 255, 0.1)', offset: 0 },
            { color: 'rgba(0, 255, 0, 0.3)', offset: 0.5 },
            { color: 'rgba(255, 0, 0, 0.5)', offset: 1 }
          ],
          radius: 10
        });
        
        const heatmapData = [];
        const now = Math.floor(Date.now() / 1000);
        const oneHourAgo = now - 3600;
        
        liquidityHistory.forEach(snapshot => {
          if (snapshot.time >= oneHourAgo * 1000) {
            [...snapshot.bids, ...snapshot.asks].forEach(order => {
              if (order.usdt >= LARGE_ORDER_THRESHOLD / 10) {
                heatmapData.push({
                  time: Math.floor(snapshot.time / 1000),
                  value: order.price,
                  intensity: Math.min(1, order.usdt / VERY_LARGE_ORDER_THRESHOLD)
                });
              }
            });
          }
        });
        
        heatmapSeries.setData(heatmapData);
        window.heatmapSeries = heatmapSeries;
      } else if (chart && window.heatmapSeries) {
        chart.removeSeries(window.heatmapSeries);
        window.heatmapSeries = null;
      }
    }
    
    // Guardar niveles clave
    function saveKeyLevels() {
      const keyLevels = {
        bids: futuresBidsData.filter(b => b.usdt >= LARGE_ORDER_THRESHOLD),
        asks: futuresAsksData.filter(a => a.usdt >= LARGE_ORDER_THRESHOLD),
        timestamp: Date.now()
      };
      
      localStorage.setItem(`keyLevels_${symbol}`, JSON.stringify(keyLevels));
      showAlert(`Niveles clave guardados para ${symbol}`, 'volume');
    }
    
    // Actualizar umbrales de √≥rdenes grandes
    function updateThresholds() {
      const largeThresholdInput = document.getElementById("large-threshold");
      const veryLargeThresholdInput = document.getElementById("very-large-threshold");
      
      if (largeThresholdInput && veryLargeThresholdInput) {
        LARGE_ORDER_THRESHOLD = parseFloat(largeThresholdInput.value) || 50000000;
        VERY_LARGE_ORDER_THRESHOLD = parseFloat(veryLargeThresholdInput.value) || 100000000;
        
        updateTables();
        showAlert(`Umbrales actualizados: ${formatUsdt(LARGE_ORDER_THRESHOLD)} / ${formatUsdt(VERY_LARGE_ORDER_THRESHOLD)}`, 'volume');
      }
    }
    
    // Alternar alertas de sonido
    function toggleSoundAlerts() {
      ALERT_SETTINGS.soundEnabled = !ALERT_SETTINGS.soundEnabled;
      localStorage.setItem('alertSettings', JSON.stringify(ALERT_SETTINGS));
      
      const soundToggle = document.getElementById("sound-toggle");
      if (soundToggle) {
        soundToggle.textContent = ALERT_SETTINGS.soundEnabled ? "üîä Sonido: ON" : "üîá Sonido: OFF";
      }
    }
    
    // Inicializar sistema de alertas
    function initAlerts() {
      const savedSettings = localStorage.getItem('alertSettings');
      if (savedSettings) {
        Object.assign(ALERT_SETTINGS, JSON.parse(savedSettings));
      }
      
      const soundToggle = document.getElementById("sound-toggle");
      if (soundToggle) {
        soundToggle.textContent = ALERT_SETTINGS.soundEnabled ? "üîä Sonido: ON" : "üîá Sonido: OFF";
      }
      
      setInterval(checkAlerts, 10000);
    }
    
    // Verificar condiciones para alertas
    function checkAlerts() {
        if (!markPriceFutures || futuresBidsData.length === 0 || futuresAsksData.length === 0) return;

        // ============================
        //        SPREAD ALERT
        // ============================
        const spreadText = document.getElementById('market-spread').textContent;
        const spreadMatch = spreadText.match(/\(([\d.]+)%\)/);

        if (spreadMatch) {
            const spread = parseFloat(spreadMatch[1]);
            if (spread > ALERT_SETTINGS.spreadAlert) {
                // ‚¨áÔ∏è NUEVA FUNCI√ìN SIN SPAM
                createSpreadAlert(spread.toFixed(2));
            }
        }

        // ============================
        //        IMBALANCE ALERT
        // ============================
        const imbalanceText = document.getElementById('orderbook-imbalance').textContent;
        const imbalance = parseFloat(imbalanceText);

        if (Math.abs(imbalance) > ALERT_SETTINGS.imbalanceAlert) {
            const direction = imbalance > 0 ? "COMPRA" : "VENTA";
            showAlert(`Desequilibrio extremo (${direction}): ${Math.abs(imbalance).toFixed(2)}%`, 'imbalance');
        }

        // ============================
        //     LIQUIDEZ INUSUAL
        // ============================
        const bidLiquidityText = document.getElementById('total-bid-liquidity').textContent;
        const askLiquidityText = document.getElementById('total-ask-liquidity').textContent;

        const bidLiquidity = parseFloat(bidLiquidityText.replace(/[^0-9.]/g, ''));
        const askLiquidity = parseFloat(askLiquidityText.replace(/[^0-9.]/g, ''));

        if (bidLiquidity > ALERT_SETTINGS.volumeAlert) {
            showAlert(`Liquidez BID inusual: ${formatUsdt(bidLiquidity)}`, 'volume');
        }

        if (askLiquidity > ALERT_SETTINGS.volumeAlert) {
            showAlert(`Liquidez ASK inusual: ${formatUsdt(askLiquidity)}`, 'volume');
        }
    }

    
    // Mostrar alerta en el sistema
    function showAlert(message, type) {
      const existingAlerts = document.querySelectorAll('.market-alert');
      for (const alert of existingAlerts) {
        if (alert.textContent.includes(message.substring(0, 20))) {
          return;
        }
      }
      
      const alertDiv = document.createElement('div');
      alertDiv.className = `market-alert ${type}-alert`;
      alertDiv.innerHTML = `
        <span class="alert-time">${new Date().toLocaleTimeString()}</span>
        <span class="alert-message">${message}</span>
        <button class="alert-close" onclick="this.parentElement.remove()">&times;</button>
      `;
      
      document.getElementById('alert-container').prepend(alertDiv);
      
      if (ALERT_SETTINGS.soundEnabled) {
        playAlertSound(type);
      }
      
      setTimeout(() => {
        if (alertDiv.parentNode) {
          alertDiv.remove();
        }
      }, 60000);
    }
    
    // Reproducir sonido de alerta
    function playAlertSound(type) {
      // Implementaci√≥n b√°sica - puedes mejorarla con sonidos personalizados
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        oscillator.type = 'sine';
        oscillator.frequency.value = type === 'volume' ? 880 : 440;
        gainNode.gain.value = 0.1;
        
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        oscillator.start();
        setTimeout(() => {
          oscillator.stop();
        }, 300);
      } catch (e) {
        console.log('Error al reproducir sonido:', e);
      }
    }
    
    // Manejo de gr√°fico
    function initializeChart() {
      try {
        const chartContainer = document.getElementById("chart-container");
        if (!chartContainer) return;
        
        const loadingMsg = chartContainer.querySelector('.loading-message');
        if (loadingMsg) {
          loadingMsg.style.display = 'block';
          loadingMsg.textContent = "Inicializando gr√°fico...";
        }
        
        if (chart) {
          chart.remove();
          chart = null;
          candlestickSeries = null;
          emaSeries = null;
        }
        
        chart = LightweightCharts.createChart(chartContainer, {
          width: chartContainer.offsetWidth,
          height: 500,
          layout: {
            backgroundColor: '#2f2f2f',
            textColor: '#d1d4dc',
          },
          grid: {
            vertLines: { color: '#444' },
            horzLines: { color: '#444' },
          },
          timeScale: {
            timeVisible: true,
            secondsVisible: false,
            rightOffset: 10,
            lockVisibleTimeRangeOnResize: true,
            rightBarStaysOnScroll: true,
            fixLeftEdge: true
          },
          rightPriceScale: {
            borderColor: '#444',
          },
          handlingScroll: {
            mouseWheel: false,
            pressedMouseMove: false,
            horzTouchDrag: false,
            vertTouchDrag: false
          }
        });
        
        candlestickSeries = chart.addCandlestickSeries({
          upColor: '#00ff00',
          downColor: '#ff0000',
          borderVisible: false,
          wickUpColor: '#00ff00',
          wickDownColor: '#ff0000',
        });
        
        emaSeries = chart.addLineSeries({
          color: '#ff9800',
          lineWidth: 2,
          title: 'EMA 100',
        });
        
        setInterval(() => {
          if (chart) {
            chart.timeScale().fitContent();
          }
        }, 30000);
        
        if (loadingMsg) {
          loadingMsg.textContent = "Cargando datos...";
        }
      } catch (err) {
        showError(`Error al inicializar el gr√°fico: ${err.message}`);
        const loadingMsg = document.querySelector('.loading-message');
        if (loadingMsg) loadingMsg.textContent = "Error inicializando gr√°fico. Recargue la p√°gina.";
      }
    }
    
    // Autoajustar gr√°fico
    function autoScaleChart() {
      if (chart) {
        chart.timeScale().fitContent();
        chart.priceScale().applyOptions({
          autoScale: true,
        });
      }
    }
    
    // Cargar datos hist√≥ricos de velas
    async function loadHistoricalKlines() {
      try {
        const loadingMsg = document.querySelector('.loading-message');
        if (loadingMsg) loadingMsg.textContent = "Cargando datos hist√≥ricos...";
        
        const response = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${currentInterval}&limit=150`);
        if (!response.ok) throw new Error(`Error HTTP: ${response.status}`);
        
        const data = await response.json();
        candlesData = data.map(kline => ({
          time: Math.floor(kline[0] / 1000),
          open: parseFloat(kline[1]),
          high: parseFloat(kline[2]),
          low: parseFloat(kline[3]),
          close: parseFloat(kline[4]),
        }));
        
        if (candlestickSeries) {
          candlestickSeries.setData(candlesData);
          const ema100 = calculateEMA(candlesData, 100);
          if (emaSeries) emaSeries.setData(ema100);
          chart.timeScale().fitContent();
          
          const loadingMsg = document.querySelector('.loading-message');
        if (loadingMsg) loadingMsg.style.display = 'none';
        }
      } catch (err) {
        showError(`Error al cargar el historial de velas: ${err.message}`);
        const loadingMsg = document.querySelector('.loading-message');
        if (loadingMsg) loadingMsg.textContent = "Error cargando datos. Intentando reconectar...";
        
        setTimeout(loadHistoricalKlines, 5000);
      }
    }
    
    function calculateEMA(data, period) {
      if (data.length < period) return [];
      
      const k = 2 / (period + 1);
      const emaData = [];
      let ema = data.slice(0, period).reduce((sum, candle) => sum + candle.close, 0) / period;
      
      emaData.push({ time: data[period - 1].time, value: ema });
      
      for (let i = period; i < data.length; i++) {
        ema = (data[i].close * k) + (ema * (1 - k));
        emaData.push({ time: data[i].time, value: ema });
      }
      
      return emaData;
    }
    
    // Manejo de l√≠neas de precio seleccionadas
    function drawSelectedPriceLine(price, isAsk) {
      if (!chart || !candlestickSeries) return;
      
      const now = Math.floor(Date.now() / 1000);
      const lineSeries = chart.addLineSeries({
        color: isAsk ? '#ff0000' : '#00ff00',
        lineWidth: 2,
        priceLineVisible: false,
        lastValueVisible: false,
      });
      
      lineSeries.setData([
        { time: now - 86400, value: price },
        { time: now, value: price },
      ]);
      
      lineSeries.createPriceLine({
        price: price,
        color: isAsk ? '#ff0000' : '#00ff00',
        lineWidth: 1,
        lineStyle: LightweightCharts.LineStyle.Dashed,
        title: `${isAsk ? 'Ask' : 'Bid'}: ${formatPrice(price)}`,
      });
      
      selectedPrices.set(price, { series: lineSeries, isAsk: isAsk });
      saveSelectedPrices();
    }
    
    function removeSelectedPriceLine(price) {
      if (!chart) return;
      
      const priceData = selectedPrices.get(price);
      if (priceData && priceData.series) {
        try {
          chart.removeSeries(priceData.series);
        } catch (err) {
          console.warn(`Error al remover serie: ${err.message}`);
        }
      }
      
      selectedPrices.delete(price);
      saveSelectedPrices();
    }
    
    function redrawSelectedLines() {
      if (!chart) return;
      
      const pricesToRedraw = new Map(selectedPrices);
      selectedPrices.clear();
      
      pricesToRedraw.forEach((data, price) => {
        if (data.series) {
          try {
            chart.removeSeries(data.series);
          } catch (err) {
            console.warn(`Error al remover serie: ${err.message}`);
          }
        }
        
        if (futuresAsksData.some(order => order.price === price) || 
            futuresBidsData.some(order => order.price === price)) {
          const isAsk = futuresAsksData.some(order => order.price === price);
          drawSelectedPriceLine(price, isAsk);
        }
      });
    }
    
    function togglePriceSelection(price, isAsk, checkbox) {

      if (checkbox.checked) {
        if (!selectedPrices.has(price)) {
          drawSelectedPriceLine(price, isAsk);
          if (isAsk) {
            asksPriceMap.set(price, true);
          } else {
            bidsPriceMap.set(price, true);
          }
        }
      } else {
        if (selectedPrices.has(price)) {
          removeSelectedPriceLine(price);
          asksPriceMap.delete(price);
          bidsPriceMap.delete(price);
        }
      }
    }
    
    function saveSelectedPrices() {
      const prices = Array.from(selectedPrices.keys());
      localStorage.setItem(`selectedPrices_${symbol}`, JSON.stringify(prices));
    }
    
    // Cambiar intervalo del gr√°fico
    function changeChartInterval() {
      const newInterval = document.getElementById("interval-select").value;
      if (newInterval === currentInterval) return;
      
      currentInterval = newInterval;
      localStorage.setItem('chartInterval', currentInterval);
      
      showError("Cambiando intervalo de velas...");
      candlesData = [];
      
      if (candlestickSeries) {
        candlestickSeries.setData([]);
      }
      
      if (emaSeries) {
        emaSeries.setData([]);
      }
      
      initializeKlineSocket();
      loadHistoricalKlines().then(() => {
        clearError();
      }).catch((err) => {
        showError(`Error al cambiar intervalo: ${err.message}`);
        setTimeout(clearError, 5000);
      });
    }
    
    // Cargar pares de criptomonedas
    async function loadCryptoPairs() {
      try {
        const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
        if (!response.ok) throw new Error('Error al obtener pares de futuros');
        
        const data = await response.json();
        const datalist = document.getElementById('symbol-list');
        const validPairs = data.symbols
          .filter(s => s.status === 'TRADING' && s.quoteAsset === 'USDT')
          .map(s => s.symbol);
        
        datalist.innerHTML = '';
        validPairs.forEach(pair => {
          const option = document.createElement('option');
          option.value = pair;
          datalist.appendChild(option);
        });
      } catch (err) {
        console.error('Error al cargar pares:', err);
        showError(`Error al cargar pares: ${err.message}`);
      }
    }
    
    // Formateadores
    function formatPrice(price) {
      const decimals = getDecimals(symbol);
      return price.toFixed(decimals).replace(/(\.\d+?)0+$/, "$1");
    }
    
    function getDecimals(symbol) {
      const decimalsMap = {
        "BTCUSDT": 2,
        "ETHUSDT": 2,
        "BNBUSDT": 2,
        "SOLUSDT": 4,
        "XRPUSDT": 4,
        "ADAUSDT": 5,
        "DOGEUSDT": 5,
        "DOTUSDT": 3,
        "MATICUSDT": 4,
        "LTCUSDT": 2,
        "AVAXUSDT": 3,
        "LINKUSDT": 3,
        "ATOMUSDT": 3,
        "UNIUSDT": 3,
        "FILUSDT": 3,
        "XLMUSDT": 5,
        "ETCUSDT": 3,
        "XTZUSDT": 3,
        "SUSHIUSDT": 3,
        "AAVEUSDT": 2,
        "GRTUSDT": 5,
        "ALGOUSDT": 4,
        "KSMUSDT": 2,
        "COMPUSDT": 2,
        "YFIUSDT": 2,
        "SNXUSDT": 3,
        "BALUSDT": 3,
        "CRVUSDT": 4,
        "SANDUSDT": 5,
        "MANAUSDT": 5,
        "AXSUSDT": 3,
        "GALAUSDT": 6,
        "APEUSDT": 4,
        "PEOPLEUSDT": 6,
        "ENSUSDT": 3,
        "ANTUSDT": 3,
        "GMTUSDT": 4,
        "GALUSDT": 5,
        "OPUSDT": 4,
        "INJUSDT": 3,
        "STGUSDT": 4,
        "SPELLUSDT": 6,
        "1000SHIBUSDT": 6,
        "1000PEPEUSDT": 8,
        "1000FLOKIUSDT": 7,
        "1000LUNCUSDT": 6,
        "1000XECUSDT": 6
      };
      
      return decimalsMap[symbol] || 4;
    }
    
    function formatQuantity(quantity) {
      if (quantity >= 1000000) return (quantity / 1000000).toFixed(2) + "M";
      if (quantity >= 1000) return (quantity / 1000).toFixed(2) + "K";
      return quantity.toFixed(4);
    }
    
    function formatUsdt(value) {
      if (value >= 1000000000) return (value / 1000000000).toFixed(2) + "B";
      if (value >= 1000000) return (value / 1000000).toFixed(2) + "M";
      if (value >= 1000) return (value / 1000).toFixed(2) + "K";
      return value.toFixed(2);
    }
    
    function formatAge(milliseconds) {
      if (milliseconds < 0) return "0s";
      
      const totalSeconds = Math.floor(milliseconds / 1000);
      
      if (totalSeconds < 60) return `${totalSeconds}s`;
      
      if (totalSeconds < 3600) return `${Math.floor(totalSeconds / 60)}m`;
      
      if (totalSeconds < 86400) return `${Math.floor(totalSeconds / 3600)}h`;
      
      return `${Math.floor(totalSeconds / 86400)}d`;
    }
    
    function updateTimestamp() {
      const now = new Date();
      const offset = -4 * 60 * 60 * 1000; // GMT-4
      const localTime = new Date(now.getTime() + offset);
      
      const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      const months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
      
      const dayName = days[localTime.getUTCDay()];
      const month = months[localTime.getUTCMonth()];
      const date = String(localTime.getUTCDate()).padStart(2, '0');
      const year = localTime.getUTCFullYear();
      
      let hours = localTime.getUTCHours();
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12;
      hours = hours ? hours : 12;
      const minutes = String(localTime.getUTCMinutes()).padStart(2, '0');
      const seconds = String(localTime.getUTCSeconds()).padStart(2, '0');
      const milliseconds = String(localTime.getUTCMilliseconds()).padStart(3, '0').slice(0,1);
      
      document.getElementById('compact-timestamp').textContent = 
        `${dayName} ${month}/${date}/${year}, ${hours}:${minutes}:${seconds}.${milliseconds} ${ampm} GMT-04:00`;
      
      if (lastPriceUpdate && (now.getTime() - lastPriceUpdate > 5000)) {
        document.getElementById("symbol-title").style.color = "#ff5555";
      } else {
        document.getElementById("symbol-title").style.color = "#55ff55";
      }
    }
    
    // Manejo de errores
    function showError(message) {
      errorMessageElement.textContent = message;
      console.error(message);
    }
    
    function clearError() {
      errorMessageElement.textContent = "";
    }
    
    function updateWsStatus(message) {
      const statusElement = document.getElementById("ws-status");
      if (!statusElement) return;

      const isConnected = message.includes("Conectado");

      statusElement.innerHTML =
        `${message} <span class="spinner" style="display:${isConnected ? 'none' : 'inline-block'}"></span>`;
    }
    
    // Configurar eventos  
    function handleTableMouseDown(event) {
      const cell = event.target.closest('.price-cell');
      if (!cell) return;
      
      const span = cell.querySelector('span');
      if (!span) return;
      
      const selection = window.getSelection();
      if (!selection.toString()) {
        const range = document.createRange();
        range.selectNodeContents(span);
        selection.removeAllRanges();
        selection.addRange(range);
      }
      
      event.preventDefault();
    }
    
    function handleTableClick(event) {
      const cell = event.target.closest('.price-cell');
      if (!cell) return;
      
      copyPriceCell({target: cell});
    }

    function handleSelectClick(event, price, isAsk) {
        event.stopPropagation();

        // Siempre encuentra el TD, no el checkbox
        const td = event.target.closest(".selected-column");
        if (!td) return;

        const cb = td.querySelector(".selection-checkbox");
        if (!cb) return;

        // Alternar estado
        cb.checked = !cb.checked;

        togglePriceSelection(price, isAsk, cb);
    }

    
    /* ============================
       üìå COPIAR PRECIO
    ============================ */
    function copyPriceCell(event) {
      const cell = event.target.closest('.price-cell');
      if (!cell) return;

      const text = cell.textContent.trim();
      if (!text) return;

      navigator.clipboard.writeText(text).then(() => {
        cell.classList.add("copied");
        setTimeout(() => cell.classList.remove("copied"), 500);
      }).catch(() => {
        copyWithFallback(text, cell);
      });

      event.preventDefault();
    }

    function copyWithFallback(text, cell) {
      const textArea = document.createElement("textarea");
      textArea.value = text;
      textArea.style.position = "fixed";
      textArea.style.opacity = "0";
      document.body.appendChild(textArea);
      textArea.select();

      try {
        document.execCommand("copy");
        cell.classList.add("copied");
        setTimeout(() => cell.classList.remove("copied"), 500);
      } catch (err) {
        console.error("Error al copiar:", err);
      }

      document.body.removeChild(textArea);
    }

    /* ============================
       üìå ALERTA DE SPREAD
    ============================ */
    function createSpreadAlert(percentage) {
      const now = Date.now();
      if (now - lastSpreadAlertTime < 4000) return;
      lastSpreadAlertTime = now;

      const alertsContainer = document.getElementById("alert-container");
      if (!alertsContainer) return;

      if (spreadAlertElement) spreadAlertElement.remove();

      spreadAlertElement = document.createElement("div");
      spreadAlertElement.className = "market-alert spread-alert";
      spreadAlertElement.innerHTML = `
        <span class="alert-time">${new Date().toLocaleTimeString()}</span>
        <span class="alert-message">Spread alto: ${percentage}%</span>
        <button class="alert-close" onclick="this.parentElement.remove()">‚úñ</button>
      `;

      alertsContainer.prepend(spreadAlertElement);

      setTimeout(() => {
        if (spreadAlertElement) {
          spreadAlertElement.remove();
          spreadAlertElement = null;
        }
      }, 10000);
    }


    /* ============================
       üöÄ INICIALIZACI√ìN
    ============================ */
    function init() {
      loadSelectedPrices();
      setupEventListeners();
      initializeWebSockets();
      setInterval(updateTimestamp, 1000);
      loadCryptoPairs();
      initAlerts();

      // Exponer funciones globales
      window.copyPriceCell = copyPriceCell;
    }

    document.addEventListener("DOMContentLoaded", init);


    /* =======================================================
       üîç FIX DEFINITIVO BUSCADOR DE S√çMBOLOS
       YA FUNCIONA SIEMPRE ‚Äî SIN BLOQUEOS
    ======================================================= */
    document.addEventListener("DOMContentLoaded", () => {
        const search = document.getElementById("symbol-search");
        if (!search) return;

        // Cambiar par con un solo click en el datalist
        search.addEventListener("input", () => {
            const s = search.value.trim().toUpperCase();
            if (!s) return;

            if (!s.endsWith("USDT") || s.length < 6) return;

            window.location.href = `?symbol=${s}`;
        });
    });


    /* =======================================================
       ‚úÖ FIX REAL ‚Äî CLICK EN CELDA ‚ÄúSEL‚Äù PERFECTO
       Sin congelar la tabla ‚Äî sin perder filas ‚Äî sin delay
    ======================================================= */

    // CSS recomendado (agr√©galo en tu <style>)
    /*
    .selected-column { cursor: pointer; }
    .selected-column input { pointer-events: none; }
    */

    document.addEventListener("click", (e) => {
      const td = e.target.closest(".selected-column");
      if (!td) return;

      const checkbox = td.querySelector(".selection-checkbox");
      if (!checkbox) return;

      checkbox.checked = !checkbox.checked;

      const priceCell = td.parentElement.querySelector(".price-cell");
      if (!priceCell) return;

      const price = parseFloat(priceCell.textContent);
      const isAsk = td.parentElement.classList.contains("ask-row");

      togglePriceSelection(price, isAsk, checkbox);

      e.preventDefault();
      e.stopPropagation();
    });

  </script>
</body>
</html>
